<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  
    <title>
      
        Node.js-child_process |
          
            Oct1a
    </title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Oct1a,Oct1a_H,前端,技术,code">
    <meta name="description" content="Node.js-child_process|为API生，为框架死，为debug奋斗一辈子o((&gt;ω&lt; ))o">
    <meta name="author" content="Oct1a_H">
    <meta name="generator" content="hexo">
    <meta name="copyright" content="Oct1a_H">

    

        
          <meta property="algolia:search" data-application-id="8PAB37PRQA" data-api-key="6be1fd77c1546f943893acc1624e0fbe" data-index-name="blogs">
            

              

                  

                      

                          

                              
<link rel="stylesheet" href="/dist/build.css?v=1619416789282.css">


                                <script>
                                  window.isPost = true
                                  window.aomori = {
                                    
                                    
                                    
                                  }
                                  window.aomori_logo_typed_animated = true
                                  window.aomori_search_algolia = true
                                </script>

</head>

<body>

    <div class="container">
    <header class="header">
        <div class="header-type">
            
            <div class="header-type-avatar avatar avatar-sm">
                <img src="/images/oct1a.jpg" alt="Oct1a_H">
            </div>
            
            <div class="header-type-inner">
                
                    <div id="typed-strings" style="display:none">
                        <p>Oct1a</p>
                    </div>
                    <a class="header-type-title" id="typed" href="/"></a>
                
    
                
            </div>
        </div>
        <div class="header-menu">
            <div class="header-menu-inner">
                
                <a href="/">Home</a>
                
                <a href="/archives">Archives</a>
                
                <a href="/photography">Photography</a>
                
            </div>
            <div class="header-menu-social">
                
    <a class="social" target="_blank" href="https://github.com/Oct1a">
        <box-icon type='logo' name='github'></box-icon>
    </a>

    <a class="social" target="_blank" href="https://www.jianshu.com/u/c9856b5ce227">
        <box-icon type='logo' name='firebase'></box-icon>
    </a>

            </div>
        </div>

        <div class="header-menu-mobile">
            <div class="header-menu-mobile-inner" id="mobile-menu-open">
                <i class="icon icon-menu"></i>
            </div>
        </div>
    </header>

    <div class="header-menu-mobile-menu">
        <div class="header-menu-mobile-menu-bg"></div>
        <div class="header-menu-mobile-menu-wrap">
            <div class="header-menu-mobile-menu-inner">
                <div class="header-menu-mobile-menu-close" id="mobile-menu-close">
                    <i class="icon icon-cross"></i>
                </div>
                <div class="header-menu-mobile-menu-list">
                    
                    <a href="/">Home</a>
                    
                    <a href="/archives">Archives</a>
                    
                    <a href="/photography">Photography</a>
                    
                </div>
            </div>
        </div>
    </div>

</div>

    <div class="container">
        <div class="main">
            <section class="inner">
                <section class="inner-main">
                    <div class="post">
    <article id="post-ckr61fvpd00dkogdd8zj04trr" class="article article-type-post" itemscope
    itemprop="blogPost">

    <div class="article-inner">

        
          
        

        

        
        <header class="article-header">
            
  
    <h1 class="article-title" itemprop="name">
      Node.js-child_process
    </h1>
  

        </header>
        

        <div class="article-more-info article-more-info-post hairline">

            <div class="article-date">
  <time datetime="2020-04-02T05:50:58.000Z" itemprop="datePublished">2020-04-02</time>
</div>

            
            <div class="article-category">
                <a class="article-category-link" href="/categories/Node-js/">Node.js</a>
            </div>
            

            

            

        </div>

        <div class="article-entry post-inner-html hairline" itemprop="articleBody">
            <h2 id="模块概览"><a href="#模块概览" class="headerlink" title="模块概览"></a>模块概览</h2><p>在node中，child_process这个模块非常重要。掌握了它，等于在node的世界开启了一扇新的大门。</p>
<span id="more"></span>
<p>举个简单的例子：</p>
<pre><code class="javascript">const spawn = require(&#39;child_process&#39;).spawn;
const ls = spawn(&#39;ls&#39;, [&#39;-lh&#39;, &#39;/usr&#39;]);

ls.stdout.on(&#39;data&#39;, (data) =&gt; &#123;
  console.log(`stdout: $&#123;data&#125;`);
&#125;);

ls.stderr.on(&#39;data&#39;, (data) =&gt; &#123;
  console.log(`stderr: $&#123;data&#125;`);
&#125;);

ls.on(&#39;close&#39;, (code) =&gt; &#123;
  console.log(`child process exited with code $&#123;code&#125;`);
&#125;);
</code></pre>
<h2 id="几种创建子进程的方式"><a href="#几种创建子进程的方式" class="headerlink" title="几种创建子进程的方式"></a>几种创建子进程的方式</h2><p>注意事项：</p>
<ul>
<li>下面列出来的都是异步创建子进程的方式，每一种方式都有对应的同步版本。</li>
<li><code>.exec()</code>、<code>.execFile()</code>、<code>.fork()</code>底层都是通过<code>.spawn()</code>实现的。</li>
<li><code>.exec()</code>、<code>execFile()</code>额外提供了回调，当子进程停止的时候执行。</li>
</ul>
<blockquote>
<p>child_process.spawn(command[, args][, options])<br>child_process.exec(command[, options][, callback])<br>child_process.execFile(file[, args][, options][, callback])<br>child_process.fork(modulePath[, args][, options])</p>
</blockquote>
<h3 id="child-process-exec-command-options-callback"><a href="#child-process-exec-command-options-callback" class="headerlink" title="child_process.exec(command[, options][, callback])"></a>child_process.exec(command[, options][, callback])</h3><p>创建一个shell，然后在shell里执行命令。执行完成后，将stdout、stderr作为参数传入回调方法。</p>
<blockquote>
<p>spawns a shell and runs a command within that shell, passing the stdout and stderr to a callback function when complete.</p>
</blockquote>
<p>例子如下：</p>
<ol>
<li>执行成功，<code>error</code>为<code>null</code>；执行失败，<code>error</code>为<code>Error</code>实例。<code>error.code</code>为错误码，</li>
<li><code>stdout</code>、<code>stderr</code>为标准输出、标准错误。默认是字符串，除非<code>options.encoding</code>为<code>buffer</code></li>
</ol>
<pre><code class="javascript">var exec = require(&#39;child_process&#39;).exec;

// 成功的例子
exec(&#39;ls -al&#39;, function(error, stdout, stderr)&#123;
    if(error) &#123;
        console.error(&#39;error: &#39; + error);
        return;
    &#125;
    console.log(&#39;stdout: &#39; + stdout);
    console.log(&#39;stderr: &#39; + typeof stderr);
&#125;);

// 失败的例子
exec(&#39;ls hello.txt&#39;, function(error, stdout, stderr)&#123;
    if(error) &#123;
        console.error(&#39;error: &#39; + error);
        return;
    &#125;
    console.log(&#39;stdout: &#39; + stdout);
    console.log(&#39;stderr: &#39; + stderr);
&#125;);
</code></pre>
<h4 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a>参数说明：</h4><ul>
<li><code>cwd</code>：当前工作路径。</li>
<li><code>env</code>：环境变量。</li>
<li><code>encoding</code>：编码，默认是<code>utf8</code>。</li>
<li><code>shell</code>：用来执行命令的shell，unix上默认是<code>/bin/sh</code>，windows上默认是<code>cmd.exe</code>。</li>
<li><code>timeout</code>：默认是0。</li>
<li><code>killSignal</code>：默认是<code>SIGTERM</code>。</li>
<li><code>uid</code>：执行进程的uid。</li>
<li><code>gid</code>：执行进程的gid。</li>
<li><code>maxBuffer</code>：<Number> 标准输出、错误输出最大允许的数据量（单位为字节），如果超出的话，子进程就会被杀死。默认是200*1024（就是200k啦）</li>
</ul>
<p>备注：</p>
<ol>
<li>如果<code>timeout</code>大于0，那么，当子进程运行超过<code>timeout</code>毫秒，那么，就会给进程发送<code>killSignal</code>指定的信号（比如<code>SIGTERM</code>）。</li>
<li>如果运行没有出错，那么<code>error</code>为<code>null</code>。如果运行出错，那么，<code>error.code</code>就是退出代码（exist code），<code>error.signal</code>会被设置成终止进程的信号。（比如<code>CTRL+C</code>时发送的<code>SIGINT</code>）</li>
</ol>
<h4 id="风险项"><a href="#风险项" class="headerlink" title="风险项"></a>风险项</h4><p>传入的命令，如果是用户输入的，有可能产生类似sql注入的风险，比如</p>
<pre><code>exec(&#39;ls hello.txt; rm -rf *&#39;, function(error, stdout, stderr)&#123;
    if(error) &#123;
        console.error(&#39;error: &#39; + error);
        // return;
    &#125;
    console.log(&#39;stdout: &#39; + stdout);
    console.log(&#39;stderr: &#39; + stderr);
&#125;);
</code></pre>
<h4 id="备注事项"><a href="#备注事项" class="headerlink" title="备注事项"></a>备注事项</h4><p>Note: Unlike the exec(3) POSIX system call, child_process.exec() does not replace the existing process and uses a shell to execute the command.</p>
<h3 id="child-process-execFile-file-args-options-callback"><a href="#child-process-execFile-file-args-options-callback" class="headerlink" title="child_process.execFile(file[, args][, options][, callback])"></a>child_process.execFile(file[, args][, options][, callback])</h3><p>跟<code>.exec()</code>类似，不同点在于，没有创建一个新的shell。至少有两点影响</p>
<ol>
<li>比<code>child_process.exec()</code>效率高一些。（实际待测试）</li>
<li>一些操作，比如I/O重定向，文件glob等不支持。</li>
</ol>
<blockquote>
<p>similar to child_process.exec() except that it spawns the command directly without first spawning a shell.</p>
</blockquote>
<p><code>file</code>：<String> 可执行文件的名字，或者路径。</p>
<p>例子：</p>
<pre><code class="javascript">var child_process = require(&#39;child_process&#39;);

child_process.execFile(&#39;node&#39;, [&#39;--version&#39;], function(error, stdout, stderr)&#123;
    if(error)&#123;
        throw error;
    &#125;
    console.log(stdout);
&#125;);

child_process.execFile(&#39;/Users/a/.nvm/versions/node/v6.1.0/bin/node&#39;, [&#39;--version&#39;], function(error, stdout, stderr)&#123;
    if(error)&#123;
        throw error;
    &#125;
    console.log(stdout);
&#125;);
</code></pre>
<p>====== 扩展阅读 =======</p>
<p>从node源码来看，<code>exec()</code>、<code>execFile()</code>最大的差别，就在于是否创建了shell。（execFile()内部，options.shell === false），那么，可以手动设置shell。以下代码差不多是等价的。win下的shell设置有所不同，感兴趣的同学可以自己试验下。</p>
<p>备注：execFile()内部最终还是通过spawn()实现的， 如果没有设置 {shell: ‘/bin/bash’}，那么 spawm() 内部对命令的解析会有所不同，execFile(‘ls -al .’) 会直接报错。</p>
<pre><code class="javascript">var child_process = require(&#39;child_process&#39;);
var execFile = child_process.execFile;
var exec = child_process.exec;

exec(&#39;ls -al .&#39;, function(error, stdout, stderr)&#123;
    if(error)&#123;
        throw error;
    &#125;
    console.log(stdout);
&#125;);

execFile(&#39;ls -al .&#39;, &#123;shell: &#39;/bin/bash&#39;&#125;, function(error, stdout, stderr)&#123;
    if(error)&#123;
        throw error;
    &#125;
    console.log(stdout);
&#125;);
</code></pre>
<h3 id="child-process-fork-modulePath-args-options"><a href="#child-process-fork-modulePath-args-options" class="headerlink" title="child_process.fork(modulePath[, args][, options])"></a>child_process.fork(modulePath[, args][, options])</h3><p><code>modulePath</code>：子进程运行的模块。</p>
<p>参数说明：（重复的参数说明就不在这里列举）</p>
<ul>
<li><code>execPath</code>：<String> 用来创建子进程的可执行文件，默认是<code>/usr/local/bin/node</code>。也就是说，你可通过<code>execPath</code>来指定具体的node可执行文件路径。（比如多个node版本）</li>
<li><code>execArgv</code>：<Array> 传给可执行文件的字符串参数列表。默认是<code>process.execArgv</code>，跟父进程保持一致。</li>
<li><code>silent</code>：<Boolean> 默认是<code>false</code>，即子进程的<code>stdio</code>从父进程继承。如果是<code>true</code>，则直接<code>pipe</code>向子进程的<code>child.stdin</code>、<code>child.stdout</code>等。</li>
<li><code>stdio</code>：<Array> 如果声明了<code>stdio</code>，则会覆盖<code>silent</code>选项的设置。</li>
</ul>
<p>例子1：silent</p>
<p><strong>parent.js</strong></p>
<pre><code class="javascript">var child_process = require(&#39;child_process&#39;);

// 例子一：会打印出 output from the child
// 默认情况，silent 为 false，子进程的 stdout 等
// 从父进程继承
child_process.fork(&#39;./child.js&#39;, &#123;
    silent: false
&#125;);

// 例子二：不会打印出 output from the silent child
// silent 为 true，子进程的 stdout 等
// pipe 向父进程
child_process.fork(&#39;./silentChild.js&#39;, &#123;
    silent: true
&#125;);

// 例子三：打印出 output from another silent child
var child = child_process.fork(&#39;./anotherSilentChild.js&#39;, &#123;
    silent: true
&#125;);

child.stdout.setEncoding(&#39;utf8&#39;);
child.stdout.on(&#39;data&#39;, function(data)&#123;
    console.log(data);
&#125;);
</code></pre>
<p><strong>child.js</strong></p>
<pre><code class="javascript">console.log(&#39;output from the child&#39;);
</code></pre>
<p><strong>silentChild.js</strong></p>
<pre><code class="javascript">console.log(&#39;output from the silent child&#39;);
</code></pre>
<p><strong>anotherSilentChild.js</strong></p>
<pre><code class="javascript">console.log(&#39;output from another silent child&#39;);
</code></pre>
<p>例子二：ipc</p>
<p>parent.js</p>
<pre><code class="javascript">var child_process = require(&#39;child_process&#39;);

var child = child_process.fork(&#39;./child.js&#39;);

child.on(&#39;message&#39;, function(m)&#123;
    console.log(&#39;message from child: &#39; + JSON.stringify(m));
&#125;);

child.send(&#123;from: &#39;parent&#39;&#125;);
</code></pre>
<p>child.js</p>
<pre><code class="javascript">process.on(&#39;message&#39;, function(m)&#123;
    console.log(&#39;message from parent: &#39; + JSON.stringify(m));
&#125;);

process.send(&#123;from: &#39;child&#39;&#125;);
</code></pre>
<p>运行结果</p>
<pre><code class="powershell">➜  ipc git:(master) ✗ node parent.js
message from child: &#123;&quot;from&quot;:&quot;child&quot;&#125;
message from parent: &#123;&quot;from&quot;:&quot;parent&quot;&#125;
</code></pre>
<p>例子三：execArgv</p>
<p>首先，process.execArgv的定义，参考<a target="_blank" rel="noopener" href="https://nodejs.org/api/process.html#process_process_execargv">这里</a>。设置<code>execArgv</code>的目的一般在于，让子进程跟父进程保持相同的执行环境。</p>
<p>比如，父进程指定了<code>--harmony</code>，如果子进程没有指定，那么就要跪了。</p>
<p>parent.js</p>
<pre><code class="javascript">var child_process = require(&#39;child_process&#39;);

console.log(&#39;parent execArgv: &#39; + process.execArgv);

child_process.fork(&#39;./child.js&#39;, &#123;
    execArgv: process.execArgv
&#125;);
</code></pre>
<p>child.js</p>
<pre><code class="javascript">console.log(&#39;child execArgv: &#39; + process.execArgv);
</code></pre>
<p>运行结果</p>
<pre><code class="powershell">➜  execArgv git:(master) ✗ node --harmony parent.js
parent execArgv: --harmony
child execArgv: --harmony
</code></pre>
<p>例子3：execPath（TODO 待举例子）</p>
<h3 id="child-process-spawn-command-args-options"><a href="#child-process-spawn-command-args-options" class="headerlink" title="child_process.spawn(command[, args][, options])"></a>child_process.spawn(command[, args][, options])</h3><p><code>command</code>：要执行的命令</p>
<p>options参数说明：</p>
<ul>
<li><code>argv0</code>：[String] 这货比较诡异，在uninx、windows上表现不一样。有需要再深究。</li>
<li><code>stdio</code>：[Array] | [String] 子进程的stdio。参考<a target="_blank" rel="noopener" href="https://nodejs.org/api/child_process.html#child_process_options_stdio">这里</a></li>
<li><code>detached</code>：[Boolean] 让子进程独立于父进程之外运行。同样在不同平台上表现有差异，具体参考<a target="_blank" rel="noopener" href="https://nodejs.org/api/child_process.html#child_process_options_detached">这里</a></li>
<li><code>shell</code>：[Boolean] | [String] 如果是<code>true</code>，在shell里运行程序。默认是<code>false</code>。（很有用，比如 可以通过 /bin/sh -c xxx 来实现 .exec() 这样的效果）</li>
</ul>
<p>例子1：基础例子</p>
<pre><code class="javascript">var spawn = require(&#39;child_process&#39;).spawn;
var ls = spawn(&#39;ls&#39;, [&#39;-al&#39;]);

ls.stdout.on(&#39;data&#39;, function(data)&#123;
    console.log(&#39;data from child: &#39; + data);
&#125;);


ls.stderr.on(&#39;data&#39;, function(data)&#123;
    console.log(&#39;error from child: &#39; + data);
&#125;);

ls.on(&#39;close&#39;, function(code)&#123;
    console.log(&#39;child exists with code: &#39; + code);
&#125;);
</code></pre>
<p>例子2：声明stdio</p>
<pre><code class="javascript">var spawn = require(&#39;child_process&#39;).spawn;
var ls = spawn(&#39;ls&#39;, [&#39;-al&#39;], &#123;
    stdio: &#39;inherit&#39;
&#125;);

ls.on(&#39;close&#39;, function(code)&#123;
    console.log(&#39;child exists with code: &#39; + code);
&#125;);
</code></pre>
<p>例子3：声明使用shell</p>
<pre><code class="javascript">var spawn = require(&#39;child_process&#39;).spawn;

// 运行 echo &quot;hello nodejs&quot; | wc
var ls = spawn(&#39;bash&#39;, [&#39;-c&#39;, &#39;echo &quot;hello nodejs&quot; | wc&#39;], &#123;
    stdio: &#39;inherit&#39;,
    shell: true
&#125;);

ls.on(&#39;close&#39;, function(code)&#123;
    console.log(&#39;child exists with code: &#39; + code);
&#125;);
</code></pre>
<p>例子4：错误处理，包含两种场景，这两种场景有不同的处理方式。</p>
<ul>
<li>场景1：命令本身不存在，创建子进程报错。</li>
<li>场景2：命令存在，但运行过程报错。</li>
</ul>
<pre><code class="javascript">var spawn = require(&#39;child_process&#39;).spawn;
var child = spawn(&#39;bad_command&#39;);

child.on(&#39;error&#39;, (err) =&gt; &#123;
  console.log(&#39;Failed to start child process 1.&#39;);
&#125;);

var child2 = spawn(&#39;ls&#39;, [&#39;nonexistFile&#39;]);

child2.stderr.on(&#39;data&#39;, function(data)&#123;
    console.log(&#39;Error msg from process 2: &#39; + data);
&#125;);

child2.on(&#39;error&#39;, (err) =&gt; &#123;
  console.log(&#39;Failed to start child process 2.&#39;);
&#125;);
</code></pre>
<p>运行结果如下。</p>
<pre><code class="powershell">➜  spawn git:(master) ✗ node error/error.js
Failed to start child process 1.
Error msg from process 2: ls: nonexistFile: No such file or directory
</code></pre>
<p>例子5：echo “hello nodejs” | grep “nodejs”</p>
<pre><code class="javascript">// echo &quot;hello nodejs&quot; | grep &quot;nodejs&quot;
var child_process = require(&#39;child_process&#39;);

var echo = child_process.spawn(&#39;echo&#39;, [&#39;hello nodejs&#39;]);
var grep = child_process.spawn(&#39;grep&#39;, [&#39;nodejs&#39;]);

grep.stdout.setEncoding(&#39;utf8&#39;);

echo.stdout.on(&#39;data&#39;, function(data)&#123;
    grep.stdin.write(data);
&#125;);

echo.on(&#39;close&#39;, function(code)&#123;
    if(code!==0)&#123;
        console.log(&#39;echo exists with code: &#39; + code);
    &#125;
    grep.stdin.end();
&#125;);

grep.stdout.on(&#39;data&#39;, function(data)&#123;
    console.log(&#39;grep: &#39; + data);
&#125;);

grep.on(&#39;close&#39;, function(code)&#123;
    if(code!==0)&#123;
        console.log(&#39;grep exists with code: &#39; + code);
    &#125;
&#125;);
</code></pre>
<p>运行结果：</p>
<pre><code class="powershell">➜  spawn git:(master) ✗ node pipe/pipe.js
grep: hello nodejs
</code></pre>
<h2 id="关于options-stdio"><a href="#关于options-stdio" class="headerlink" title="关于options.stdio"></a>关于<code>options.stdio</code></h2><p>默认值：[‘pipe’, ‘pipe’, ‘pipe’]，这意味着：</p>
<ol>
<li>child.stdin、child.stdout 不是<code>undefined</code></li>
<li>可以通过监听 <code>data</code> 事件，来获取数据。</li>
</ol>
<h3 id="基础例子"><a href="#基础例子" class="headerlink" title="基础例子"></a>基础例子</h3><pre><code class="javascript">var spawn = require(&#39;child_process&#39;).spawn;
var ls = spawn(&#39;ls&#39;, [&#39;-al&#39;]);

ls.stdout.on(&#39;data&#39;, function(data)&#123;
    console.log(&#39;data from child: &#39; + data);
&#125;);

ls.on(&#39;close&#39;, function(code)&#123;
    console.log(&#39;child exists with code: &#39; + code);
&#125;);
</code></pre>
<h3 id="通过child-stdin-write-写入"><a href="#通过child-stdin-write-写入" class="headerlink" title="通过child.stdin.write()写入"></a>通过child.stdin.write()写入</h3><pre><code class="javascript">var spawn = require(&#39;child_process&#39;).spawn;
var grep = spawn(&#39;grep&#39;, [&#39;nodejs&#39;]);

setTimeout(function()&#123;
    grep.stdin.write(&#39;hello nodejs \n hello javascript&#39;);
    grep.stdin.end();
&#125;, 2000);

grep.stdout.on(&#39;data&#39;, function(data)&#123;
    console.log(&#39;data from grep: &#39; + data);
&#125;);

grep.on(&#39;close&#39;, function(code)&#123;
    console.log(&#39;grep exists with code: &#39; + code);
&#125;);
</code></pre>
<h2 id="异步-vs-同步"><a href="#异步-vs-同步" class="headerlink" title="异步 vs 同步"></a>异步 vs 同步</h2><p>大部分时候，子进程的创建是异步的。也就是说，它不会阻塞当前的事件循环，这对于性能的提升很有帮助。</p>
<p>当然，有的时候，同步的方式会更方便（阻塞事件循环），比如通过子进程的方式来执行shell脚本时。</p>
<p>node同样提供同步的版本，比如：</p>
<ul>
<li>spawnSync()</li>
<li>execSync()</li>
<li>execFileSync()</li>
</ul>
<h2 id="关于options-detached"><a href="#关于options-detached" class="headerlink" title="关于options.detached"></a>关于<code>options.detached</code></h2><p>由于木有在windows上做测试，于是先贴原文</p>
<blockquote>
<p>On Windows, setting options.detached to true makes it possible for the child process to continue running after the parent exits. The child will have its own console window. Once enabled for a child process, it cannot be disabled.</p>
</blockquote>
<p>在非window是平台上的表现</p>
<blockquote>
<p>On non-Windows platforms, if options.detached is set to true, the child process will be made the leader of a new process group and session. Note that child processes may continue running after the parent exits regardless of whether they are detached or not. See setsid(2) for more information.</p>
</blockquote>
<h3 id="默认情况：父进程等待子进程结束。"><a href="#默认情况：父进程等待子进程结束。" class="headerlink" title="默认情况：父进程等待子进程结束。"></a>默认情况：父进程等待子进程结束。</h3><p>子进程。可以看到，有个定时器一直在跑</p>
<pre><code class="javascript">var times = 0;
setInterval(function()&#123;
    console.log(++times);
&#125;, 1000);
</code></pre>
<p>运行下面代码，会发现父进程一直hold着不退出。</p>
<pre><code>var child_process = require(&#39;child_process&#39;);
child_process.spawn(&#39;node&#39;, [&#39;child.js&#39;], &#123;
    // stdio: &#39;inherit&#39;
&#125;);
</code></pre>
<h3 id="通过child-unref-让父进程退出"><a href="#通过child-unref-让父进程退出" class="headerlink" title="通过child.unref()让父进程退出"></a>通过child.unref()让父进程退出</h3><p>调用<code>child.unref()</code>，将子进程从父进程的事件循环中剔除。于是父进程可以愉快的退出。这里有几个要点</p>
<ol>
<li>调用<code>child.unref()</code></li>
<li>设置<code>detached</code>为<code>true</code></li>
<li>设置<code>stdio</code>为<code>ignore</code>（这点容易忘）</li>
</ol>
<pre><code class="javascript">var child_process = require(&#39;child_process&#39;);
var child = child_process.spawn(&#39;node&#39;, [&#39;child.js&#39;], &#123;
    detached: true,
    stdio: &#39;ignore&#39;  // 备注：如果不置为 ignore，那么 父进程还是不会退出
    // stdio: &#39;inherit&#39;
&#125;);

child.unref();
</code></pre>
<h3 id="将stdio重定向到文件"><a href="#将stdio重定向到文件" class="headerlink" title="将stdio重定向到文件"></a>将<code>stdio</code>重定向到文件</h3><p>除了直接将stdio设置为<code>ignore</code>，还可以将它重定向到本地的文件。</p>
<pre><code class="javascript">var child_process = require(&#39;child_process&#39;);
var fs = require(&#39;fs&#39;);

var out = fs.openSync(&#39;./out.log&#39;, &#39;a&#39;);
var err = fs.openSync(&#39;./err.log&#39;, &#39;a&#39;);

var child = child_process.spawn(&#39;node&#39;, [&#39;child.js&#39;], &#123;
    detached: true,
    stdio: [&#39;ignore&#39;, out, err]
&#125;);

child.unref();
</code></pre>
<h2 id="exec-与execFile-之间的区别"><a href="#exec-与execFile-之间的区别" class="headerlink" title="exec()与execFile()之间的区别"></a>exec()与execFile()之间的区别</h2><p>首先，exec() 内部调用 execFile() 来实现，而 execFile() 内部调用 spawn() 来实现。</p>
<blockquote>
<p>exec() -&gt; execFile() -&gt; spawn()</p>
</blockquote>
<p>其次，execFile() 内部默认将 options.shell 设置为false，exec() 默认不是false。</p>
<h2 id="Class-ChildProcess"><a href="#Class-ChildProcess" class="headerlink" title="Class: ChildProcess"></a>Class: ChildProcess</h2><ul>
<li>通过<code>child_process.spawn()</code>等创建，一般不直接用构造函数创建。</li>
<li>继承了<code>EventEmitters</code>，所以有<code>.on()</code>等方法。</li>
</ul>
<h3 id="各种事件"><a href="#各种事件" class="headerlink" title="各种事件"></a>各种事件</h3><h3 id="close"><a href="#close" class="headerlink" title="close"></a>close</h3><p>当stdio流关闭时触发。这个事件跟<code>exit</code>不同，因为多个进程可以共享同个stdio流。<br>参数：code（退出码，如果子进程是自己退出的话），signal（结束子进程的信号）<br>问题：code一定是有的吗？（从对code的注解来看好像不是）比如用<code>kill</code>杀死子进程，那么，code是？</p>
<h3 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h3><p>参数：code、signal，如果子进程是自己退出的，那么<code>code</code>就是退出码，否则为null；如果子进程是通过信号结束的，那么，<code>signal</code>就是结束进程的信号，否则为null。这两者中，一者肯定不为null。<br>注意事项：<code>exit</code>事件触发时，子进程的stdio stream可能还打开着。（场景？）此外，nodejs监听了SIGINT和SIGTERM信号，也就是说，nodejs收到这两个信号时，不会立刻退出，而是先做一些清理的工作，然后重新抛出这两个信号。（目测此时js可以做清理工作了，比如关闭数据库等。TODO 疑问：js里面是否也可以不退出？？？？）</p>
<p>SIGINT：interrupt，程序终止信号，通常在用户按下CTRL+C时发出，用来通知前台进程终止进程。<br>SIGTERM：terminate，程序结束信号，该信号可以被阻塞和处理，通常用来要求程序自己正常退出。shell命令kill缺省产生这个信号。如果信号终止不了，我们才会尝试SIGKILL（强制终止）。</p>
<blockquote>
<p>Also, note that Node.js establishes signal handlers for SIGINT and SIGTERM and Node.js processes will not terminate immediately due to receipt of those signals. Rather, Node.js will perform a sequence of cleanup actions and then will re-raise the handled signal.</p>
</blockquote>
<h3 id="error"><a href="#error" class="headerlink" title="error"></a>error</h3><p>当发生下列事情时，error就会被触发。当error触发时，exit可能触发，也可能不触发。（内心是崩溃的）</p>
<ul>
<li>无法创建子进程。</li>
<li>进程无法kill。（TODO 例子）</li>
<li>向子进程发送消息失败。（TODO  例子）</li>
</ul>
<h3 id="message"><a href="#message" class="headerlink" title="message"></a>message</h3><p>当采用<code>process.send()</code>来发送消息时触发。<br>参数：<code>message</code>，为json对象，或者primitive value；<code>sendHandle</code>，net.Socket对象，或者net.Server对象（TODO 什么时候是什么对象？？？）</p>
<p><strong>.connected</strong>：当调用<code>.disconnected()</code>时，设为false。代表是否能够从子进程接收消息，或者对子进程发送消息。</p>
<p>**.disconnect()**：关闭父进程、子进程之间的IPC通道。当这个方法被调用时，<code>disconnect</code>事件就会触发。如果子进程是node实例（通过child_process.fork()创建），那么在子进程内部也可以主动调用<code>process.disconnect()</code>来终止IPC通道。参考<a target="_blank" rel="noopener" href="https://nodejs.org/api/process.html#process_process_disconnect">process.disconnect</a>。<br>疑问：比如fork了个子进程，子进程里启动了http server，那么，父进程调用 <code>.disconnect()</code>的影响？（TODO 求验证？？？）</p>
<h2 id="非重要的备忘点"><a href="#非重要的备忘点" class="headerlink" title="非重要的备忘点"></a>非重要的备忘点</h2><h3 id="windows平台上的cmd、bat"><a href="#windows平台上的cmd、bat" class="headerlink" title="windows平台上的cmd、bat"></a>windows平台上的<code>cmd</code>、<code>bat</code></h3><blockquote>
<p>The importance of the distinction between child_process.exec() and child_process.execFile() can vary based on platform. On Unix-type operating systems (Unix, Linux, OSX) child_process.execFile() can be more efficient because it does not spawn a shell. On Windows, however, .bat and .cmd files are not executable on their own without a terminal, and therefore cannot be launched using child_process.execFile(). When running on Windows, .bat and .cmd files can be invoked using child_process.spawn() with the shell option set, with child_process.exec(), or by spawning cmd.exe and passing the .bat or .cmd file as an argument (which is what the shell option and child_process.exec() do).</p>
</blockquote>
<pre><code class="javascript">// On Windows Only ...
const spawn = require(&#39;child_process&#39;).spawn;
const bat = spawn(&#39;cmd.exe&#39;, [&#39;/c&#39;, &#39;my.bat&#39;]);

bat.stdout.on(&#39;data&#39;, (data) =&gt; &#123;
  console.log(data);
&#125;);

bat.stderr.on(&#39;data&#39;, (data) =&gt; &#123;
  console.log(data);
&#125;);

bat.on(&#39;exit&#39;, (code) =&gt; &#123;
  console.log(`Child exited with code $&#123;code&#125;`);
&#125;);

// OR...
const exec = require(&#39;child_process&#39;).exec;
exec(&#39;my.bat&#39;, (err, stdout, stderr) =&gt; &#123;
  if (err) &#123;
    console.error(err);
    return;
  &#125;
  console.log(stdout);
&#125;);
</code></pre>
<h3 id="进程标题"><a href="#进程标题" class="headerlink" title="进程标题"></a>进程标题</h3><p>Note: Certain platforms (OS X, Linux) will use the value of argv[0] for the process title while others (Windows, SunOS) will use command.</p>
<p>Note: Node.js currently overwrites argv[0] with process.execPath on startup, so process.argv[0] in a Node.js child process will not match the argv0 parameter passed to spawn from the parent, retrieve it with the process.argv0 property instead.</p>
<h3 id="代码运行次序的问题"><a href="#代码运行次序的问题" class="headerlink" title="代码运行次序的问题"></a>代码运行次序的问题</h3><p><strong>p.js</strong></p>
<pre><code class="javascript">const cp = require(&#39;child_process&#39;);
const n = cp.fork(`$&#123;__dirname&#125;/sub.js`);

console.log(&#39;1&#39;);

n.on(&#39;message&#39;, (m) =&gt; &#123;
  console.log(&#39;PARENT got message:&#39;, m);
&#125;);

console.log(&#39;2&#39;);

n.send(&#123; hello: &#39;world&#39; &#125;);

console.log(&#39;3&#39;);
</code></pre>
<p><strong>sub.js</strong></p>
<pre><code class="javascript">console.log(&#39;4&#39;);
process.on(&#39;message&#39;, (m) =&gt; &#123;
  console.log(&#39;CHILD got message:&#39;, m);
&#125;);

process.send(&#123; foo: &#39;bar&#39; &#125;);
console.log(&#39;5&#39;);
</code></pre>
<p>运行<code>node p.js</code>，打印出来的内容如下</p>
<pre><code class="powershell">➜  ch node p.js
1
2
3
4
5
PARENT got message: &#123; foo: &#39;bar&#39; &#125;
CHILD got message: &#123; hello: &#39;world&#39; &#125;
</code></pre>
<p>再来个例子</p>
<pre><code class="javascript">// p2.js
var fork = require(&#39;child_process&#39;).fork;

console.log(&#39;p: 1&#39;);

fork(&#39;./c2.js&#39;);

console.log(&#39;p: 2&#39;);

// 从测试结果来看，同样是70ms，有的时候，定时器回调比子进程先执行，有的时候比子进程慢执行。
const t = 70;
setTimeout(function()&#123;
    console.log(&#39;p: 3 in %s&#39;, t);
&#125;, t);


// c2.js
console.log(&#39;c: 1&#39;);
</code></pre>
<h3 id="关于NODE-CHANNEL-FD"><a href="#关于NODE-CHANNEL-FD" class="headerlink" title="关于NODE_CHANNEL_FD"></a>关于NODE_CHANNEL_FD</h3><p>child_process.fork()时，如果指定了execPath，那么父、子进程间通过NODE_CHANNEL_FD 进行通信。</p>
<blockquote>
<p>Node.js processes launched with a custom execPath will communicate with the parent process using the file descriptor (fd) identified using the environment variable NODE_CHANNEL_FD on the child process. The input and output on this fd is expected to be line delimited JSON objects.</p>
</blockquote>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p>官方文档：<a target="_blank" rel="noopener" href="https://nodejs.org/api/child_process.html">https://nodejs.org/api/child_process.html</a></p>

        </div>

    </div>

    

    

    

    
<div class="article-copyright hairline">
  <p>
    本作品采用 <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc-nd/4.0/">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a> 进行许可。
  </p>
</div>


    

    
<nav class="article-nav">
  
    <a href="/article/2020/04/Node-js/2020-05-%E5%9B%BE%E7%89%87%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%88%90datauri.html" id="article-nav-newer" class="article-nav-link-wrap">
      <div class="article-nav-caption">下一篇</div>
      <div class="article-nav-title">
        
          Node.js-buffer
        
      </div>
    </a>
  
  
    <a href="/article/2020/04/Node-js/2020-04-fs.html" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-caption">上一篇</div>
      <div class="article-nav-title">Node.js-fs</div>
    </a>
  
</nav>


    <section class="share">
        <div class="share-title">分享</div>
        <a class="share-item" target="_blank"
            href="https://www.facebook.com/sharer.php?title=Node.js-child_process - Oct1a&u=https://oct1a.cn/article/2020/04/Node-js/2020-04-child-process.html">
            <box-icon name='facebook-square' type='logo' ></box-icon>
        </a>
        <a class="share-item" target="_blank"
            href="https://service.weibo.com/share/share.php?title=Node.js-child_process - Oct1a&url=https://oct1a.cn/article/2020/04/Node-js/2020-04-child-process.html&pic=">
            <box-icon name='pinterest-alt' type='logo' ></box-icon>
        </a>
    </section>

</article>












</div>
                </section>
            </section>

            
            <aside class="sidebar sidebar-search-fix">
                

    <div class="search">
    <div class="has-icon-right">
        <input type="text" class="form-input" id="search" placeholder="SEARCH" autocomplete="off">
        <div class="form-icon">
            <box-icon name='search' color="#3c4859"></box-icon>
        </div>
    </div>
    <div class="search-result" id="search-ps"></div>
</div>


<div class="widget" id="widget">
    
      
  <div class="widget-wrap">
    <div class="widget-inner">
      <div class="toc post-toc-html"></div>
    </div>
  </div>

    
      
  <div class="widget-wrap widget-cate">
    <div class="widget-title"><span>Categories</span></div>
    <div class="widget-inner">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Node-js/">Node.js</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Windows/">Windows</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/web%E5%89%8D%E7%AB%AF/">web前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%85%B6%E5%AE%83/">其它</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/">工具使用</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/">微信小程序</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%98%E8%85%BE%E6%89%8B%E6%9C%BA/">折腾手机</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%8E%A9%E8%BD%AC%E6%9C%8D%E5%8A%A1%E5%99%A8/">玩转服务器</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/">自动化测试</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap widget-tags">
    <div class="widget-title"><span>Tags</span></div>
    <div class="widget-inner">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AWSC/" rel="tag">AWSC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ajax/" rel="tag">Ajax</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-Stuido/" rel="tag">Android Stuido</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Apache/" rel="tag">Apache</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DevTools/" rel="tag">DevTools</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Django/" rel="tag">Django</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Esc/" rel="tag">Esc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/G-140W-CS/" rel="tag">G-140W-CS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML5/" rel="tag">HTML5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/" rel="tag">HTTP状态码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HUAWEI/" rel="tag">HUAWEI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Html/" rel="tag">Html</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ICP/" rel="tag">ICP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JSON/" rel="tag">JSON</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jquery/" rel="tag">Jquery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LAMP/" rel="tag">LAMP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lodash/" rel="tag">Lodash</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MD5/" rel="tag">MD5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MUI/" rel="tag">MUI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Manjaro/" rel="tag">Manjaro</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown/" rel="tag">Markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Matplotlib/" rel="tag">Matplotlib</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mysql/" rel="tag">Mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/" rel="tag">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PyInstaller/" rel="tag">PyInstaller</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Reg/" rel="tag">Reg</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SEM/" rel="tag">SEM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SEO/" rel="tag">SEO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SSL%E8%AF%81%E4%B9%A6/" rel="tag">SSL证书</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Selenium/" rel="tag">Selenium</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ubuntu/" rel="tag">Ubuntu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/" rel="tag">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue3/" rel="tag">Vue3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Webpack/" rel="tag">Webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows10/" rel="tag">Windows10</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/XHTML/" rel="tag">XHTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/YOLO/" rel="tag">YOLO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/apache/" rel="tag">apache</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/app%E4%B8%8A%E6%9E%B6/" rel="tag">app上架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bug/" rel="tag">bug</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cmd/" rel="tag">cmd</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/" rel="tag">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/darkflow/" rel="tag">darkflow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/express/" rel="tag">express</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/font/" rel="tag">font</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/" rel="tag">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pacman/" rel="tag">pacman</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php/" rel="tag">php</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pip/" rel="tag">pip</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pm2/" rel="tag">pm2</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/socket-io/" rel="tag">socket.io</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/turtle/" rel="tag">turtle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/wechat/" rel="tag">wechat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/windows11/" rel="tag">windows11</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/wordcloud/" rel="tag">wordcloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B4%E6%9C%AB%E6%80%BB%E7%BB%93/" rel="tag">年末总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8A%93%E5%8C%85/" rel="tag">抓包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA/" rel="tag">虚拟主机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E8%91%97/" rel="tag">软著</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap widget-recent-posts">
    <div class="widget-title"><span>Recent Posts</span></div>
    <div class="widget-inner">
      <ul>
        
          <li>
            <a href="/article/2021/07/web%E5%89%8D%E7%AB%AF/2021-07-%E5%89%8D%E7%AB%AF%E7%BD%91%E9%A1%B5%E5%AD%97%E4%BD%93%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97.html">前端网页字体优化的4种方案</a>
          </li>
        
          <li>
            <a href="/article/2021/07/Windows/2021-07-Window10%E5%A6%82%E4%BD%95%E5%8D%87%E7%BA%A7Window11%EF%BC%88%E4%BD%93%E9%AA%8C%E7%89%88%EF%BC%89%E8%AF%A6%E7%BB%86%E6%B5%81%E7%A8%8B.html">Window10升级Window11（体验版dev）详细流程</a>
          </li>
        
          <li>
            <a href="/article/2021/07/Windows/2021-07-%E5%AF%86%E9%92%A5%E5%8D%87%E7%BA%A7windows%E4%B8%93%E4%B8%9A%E7%89%88%E5%8D%87%E7%BA%A7%E5%AF%86%E9%92%A5%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98.html">密钥升级windows专业版，升级失败，之前密钥丢失问题</a>
          </li>
        
          <li>
            <a href="/article/2021/07/%E5%85%B6%E5%AE%83/2021-06-%E7%AE%80%E4%B9%A6%E8%BF%81%E7%A7%BB%E5%8D%9A%E5%AE%A2.html">(no title)</a>
          </li>
        
          <li>
            <a href="/article/2021/06/%E5%85%B6%E5%AE%83/2021-06-%E5%BA%94%E7%94%A8%E5%AE%9D%E4%B8%8A%E6%9E%B6%E6%8C%87%E5%8D%97.html">应用宝上架指南【详细教程】</a>
          </li>
        
      </ul>
    </div>
  </div>

    
      
  <div class="widget-wrap widget-archive">
    <div class="widget-title"><span>Archive</span></div>
    <div class="widget-inner">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/">2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/">2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/">2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/">2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/">2015</a></li></ul>
    </div>
  </div>


    
</div>

<div id="backtop"><i class="icon icon-arrow-up"></i></div>
            </aside>
            
        </div>
    </div>

    <footer class="footer">
  <div class="footer-wave">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1440 320"><path fill="#3c4859" fill-opacity="1" d="M0,160L60,181.3C120,203,240,245,360,240C480,235,600,181,720,186.7C840,192,960,256,1080,261.3C1200,267,1320,213,1380,186.7L1440,160L1440,320L1380,320C1320,320,1200,320,1080,320C960,320,840,320,720,320C600,320,480,320,360,320C240,320,120,320,60,320L0,320Z"></path></svg>
  </div>

  <div class="footer-wrap">
    <div class="footer-inner">
      Oct1a &copy;
        2021<br> Powered By Hexo · Theme By <a href="https://github.com/lh1me/hexo-theme-aomori" target="_blank">Aomori</a>
          <br>
          <img width="15" src="//gw.alicdn.com/tfs/TB1GxwdSXXXXXa.aXXXXXXXXXXX-65-70.gif">
          <img width="15" src="//img.alicdn.com/tfs/TB1..50QpXXXXX7XpXXXXXXXXXX-40-40.png">
          <a target="_blank" rel="noopener" href="http://www.beian.gov.cn/portal/registerSystemInfo" style="text-decoration:none"><span style="margin-left:8px;user-select:none;-ms-user-select:none;">闽公网安备35021102001102号</span></a>
          <a target="_blank" rel="noopener" href="https://beian.miit.gov.cn" style="text-decoration:none"><span style="margin-left:8px;user-select:none;-ms-user-select:none;">闽ICP备14018417号-7</span></a>
    </div>

  </div>

</footer>



    

        
<script src="/dist/build.js?1619416789282.js"></script>

          
<script src="/dist/custom.js?1619416789282.js"></script>


            

                

                    

</body>

</html>