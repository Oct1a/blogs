<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    
    <title>Oct1a</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    

    
        <meta property="algolia:search" data-application-id="8PAB37PRQA" data-api-key="6be1fd77c1546f943893acc1624e0fbe" data-index-name="blogs">
    

    

    

    

    

    
<link rel="stylesheet" href="/dist/build.css?v=1619416789282.css">


    <script>
        window.isPost = false
        window.aomori = {
            
            
            
        }
        window.aomori_logo_typed_animated = true
        window.aomori_search_algolia = true

    </script>

<meta name="generator" content="Hexo 5.4.0"></head>

<body>

    <div class="container">
    <header class="header">
        <div class="header-type">
            
            <div class="header-type-avatar avatar avatar-sm">
                <img src="/images/oct1a.jpg" alt="Oct1a_H">
            </div>
            
            <div class="header-type-inner">
                
                    <div id="typed-strings" style="display:none">
                        <p>Oct1a</p>
                    </div>
                    <a class="header-type-title" id="typed" href="/"></a>
                
    
                
            </div>
        </div>
        <div class="header-menu">
            <div class="header-menu-inner">
                
                <a href="/">Home</a>
                
                <a href="/archives">Archives</a>
                
                <a href="/photography">Photography</a>
                
            </div>
            <div class="header-menu-social">
                
    <a class="social" target="_blank" href="https://github.com/Oct1a">
        <box-icon type='logo' name='github'></box-icon>
    </a>

    <a class="social" target="_blank" href="https://www.jianshu.com/u/c9856b5ce227">
        <box-icon type='logo' name='firebase'></box-icon>
    </a>

            </div>
        </div>

        <div class="header-menu-mobile">
            <div class="header-menu-mobile-inner" id="mobile-menu-open">
                <i class="icon icon-menu"></i>
            </div>
        </div>
    </header>

    <div class="header-menu-mobile-menu">
        <div class="header-menu-mobile-menu-bg"></div>
        <div class="header-menu-mobile-menu-wrap">
            <div class="header-menu-mobile-menu-inner">
                <div class="header-menu-mobile-menu-close" id="mobile-menu-close">
                    <i class="icon icon-cross"></i>
                </div>
                <div class="header-menu-mobile-menu-list">
                    
                    <a href="/">Home</a>
                    
                    <a href="/archives">Archives</a>
                    
                    <a href="/photography">Photography</a>
                    
                </div>
            </div>
        </div>
    </div>

</div>

    <div class="container">
        <div class="main">
            <section class="inner">
                <section class="inner-main">
                    <div class="index">
  
    
      <article
id="post-2020-05-stream"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/article/2020/04/Node-js/2020-05-stream.html">Node.js-buffer</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <p>类型：<br>自定义 ReadStream<br>自定义 WriteStream<br>自定义 DuplexStream<br>自定义 TransformStrem</p>
<p>模式对比：<br>string/buffer<br>object mode</p>
<p>缓存：(buffering、highWaterMark)</p>
<p>两种视角：<br>stream使用<br>stream实现</p>
<h2 id="Readable-Stream"><a href="#Readable-Stream" class="headerlink" title="Readable Stream"></a>Readable Stream</h2><p>可以通过两种方式从一个Readable Steram中读取数据：</p>
<ol>
<li>none-flowing：默认</li>
<li>flowing</li>
</ol>
<h3 id="none-flowing-mode"><a href="#none-flowing-mode" class="headerlink" title="none-flowing mode"></a>none-flowing mode</h3><p>以下代码从标准输入中读取内容，并写回到标准输出。</p>
<ol>
<li>read()方法是同步调用，默认返回buffer，也可以通过 readStream.setEncoding(charset) 使得取得的内容为字符串。（从内部的缓冲区里读取内容）</li>
<li>当内部缓冲区有数据可供读取时，readable触发（可能触发多次）。read() 方法会循环调用，直到返回null。此时，停止数据读取，直到下一次readable触发，或者end触发。</li>
<li>回车：process.stdin.read() 返回，程序打印标准输入的内容。</li>
<li>EOF：触发end事件，CTRL+D(linux)、CTRL+Z(windows)。</li>
</ol>
<pre><code class="javascript">process.stdin
  .on(&#39;readable&#39;, () =&gt; &#123;
    let chunk;
    while ((chunk = process.stdin.read()) !== null) &#123;
      console.log(`Buffer.isBuffer(chunk): $&#123;Buffer.isBuffer(buffer)&#125;`); // true
      console.log(`Chunk read: $&#123;chunk.toString()&#125;`);
    &#125;
  &#125;)
  .on(&#39;end&#39;, () =&gt; &#123;
    process.stdout.write(&#39;End of Stream&#39;);
  &#125;);
</code></pre>
<h3 id="flowing-mode"><a href="#flowing-mode" class="headerlink" title="flowing mode"></a>flowing mode</h3><p>跟none-flowing mode的区别：</p>
<ol>
<li>none-flowing：当内部缓冲区有数据，触发readable事件。用户需要主动调用 read() 方法读取数据。（如果用户在 readable 事件触发时，没有调用 read() 方法，会怎么样？）</li>
<li>flowing：当有数据到来时，’data’ 事件触发，同时内部缓冲区的数据会被带到回调参数里。</li>
</ol>
<pre><code class="javascript">process.stdin
  .on(&#39;data&#39;, (chunk) =&gt; &#123;
    console.log(`Buffer.isBuffer(chunk): $&#123;Buffer.isBuffer(chunk)&#125;`);
    console.log(`Chunk read: $&#123;chunk.toString()&#125;`);
  &#125;)
  .on(&#39;end&#39;, () =&gt; &#123;
    process.stdout.write(&#39;End of Stream&#39;);
  &#125;);
</code></pre>
<p>flowing mode是对旧版本stream接口的继承（换个翻译方式？Stream1），在控制数据的流向方面灵活性一般。随着Stream2接口的引入，flowing mode不是默认的模式。</p>
<p>要将stream切换到flowing mode，有两种方式：</p>
<ol>
<li>添加 ‘data’ 回调。</li>
<li>调用 resume() 方法。</li>
</ol>
<p>要让stream暂时停止抛出 ‘data’ 事件，可以调用 pause() 方法。注意，这样并不能将stream切换到none-flowing mode，只是暂停 ‘data’ 事件的触发，后续进来的数据会被缓存在内部缓冲区。</p>
<h2 id="实现Readable-Steam"><a href="#实现Readable-Steam" class="headerlink" title="实现Readable Steam"></a>实现Readable Steam</h2><pre><code class="javascript">// randomStream.js
const &#123; Readable &#125; = require(&#39;stream&#39;);

const arr = [];

class RandomStream extends Readable &#123;
  constructor (options) &#123;
    super(options);
  &#125;

  _read () &#123;
    arr.push(`[RandomStream] _read() is called`);
    let num = Math.random();
    this.push(num.toString() + &#39; &#39;, &#39;utf8&#39;);

    if (num &lt;= 0.1) &#123;
      this.push(null); // end
    &#125;
  &#125;
&#125;

const rs = new RandomStream();
rs
.on(&#39;readable&#39;, () =&gt; &#123;
  arr.push(`[readable] before loop`);

  let chunk;
  while ((chunk = rs.read()) !== null) &#123;
    arr.push(`chunk read: $&#123;chunk&#125;`);
  &#125;

  arr.push(`[readable] after loop`);
&#125;)
.on(&#39;end&#39;, () =&gt; &#123;
  arr.push(`[end]`);
  console.log(arr.join(&#39;\n&#39;));
&#125;)
</code></pre>
<p>运行结果输出如下（顺序有点不大对劲？）：</p>
<pre><code class="bash">[RandomStream] _read() is called
[readable] before loop
[RandomStream] _read() is called
chunk read: 0.9455902221151478 0.4752694596188789
[RandomStream] _read() is called
chunk read: 0.9372690495391933
[RandomStream] _read() is called
chunk read: 0.053975422709547694
[readable] after loop
[readable] before loop
[readable] after loop
[readable] before loop
[readable] after loop
[readable] before loop
[readable] after loop
[end]
</code></pre>
<h2 id="Write-Stream"><a href="#Write-Stream" class="headerlink" title="Write Stream"></a>Write Stream</h2><p>通过 write() 写入数据。如果chunk是buffer类型，encoding可以忽略不计。如果chunk是string类型，则通过encoding指定编码，默认是utf8。当chunk写入完成，callback被调用。</p>
<p>write(chunk, [encoding], [callback])</p>
<p>通过 end() 结束写入。chunk、encoding、callback 参数作用跟 write() 方法相同。这里的 callback，作用跟 .on(‘finish’, onFinishCallback) 中的 onFinishCallback 相同。</p>
<p>end(chunk, [encoding], [callback])</p>
<pre><code class="javascript">const http = require(&#39;http&#39;);
const port = 3000;

http.createServer((req, res) =&gt; &#123;
  let num;
  while ((num = Math.random()) &gt; 0.1) &#123;
    res.write(&#39;res.write(): &#39; + num.toString() + &#39;\n&#39;);
  &#125;
  res.end(&#39;res.end(): the end&#39;);
  res.on(&#39;finish&#39;, () =&gt; console.log(&#39;finished.&#39;));
&#125;).listen(port);
</code></pre>
<p>请求：</p>
<pre><code class="bash">curl http://127.0.0.1:3000
</code></pre>
<p>输出：</p>
<pre><code class="bash">res.write(): 0.3070578038171923
res.write(): 0.6395702937677197
res.write(): 0.7310690728411677
res.write(): 0.9383379632316118
res.write(): 0.47331240688271636
res.write(): 0.1311702075669403
res.write(): 0.7170623464834849
res.write(): 0.3973024871804054
res.write(): 0.7583489396978729
res.write(): 0.5808965383971327
res.write(): 0.22983892514760362
res.write(): 0.25565119168375583
res.end(): the end
</code></pre>
<p>备注：如果是通过浏览器访问，浏览器本身可能会对响应进行缓存，因此，多次调用res.write()，浏览器里有可能是一次性把内容展示出来 ）</p>
<h2 id="Duplex-Stream"><a href="#Duplex-Stream" class="headerlink" title="Duplex Stream"></a>Duplex Stream</h2><p>Duplex Stream可读、可写。开发者需要同时实现 _read()、_write() 方法。简单的例子如下：</p>
<pre><code class="javascript">const &#123; Duplex &#125; = require(&#39;stream&#39;);

class DP extends Duplex &#123;
  constructor (options = &#123;&#125;) &#123;
    super(options);
    this._innerChunks = [];
  &#125;

  _write (chunk, encoding, callback) &#123;
    this._innerChunks.push(&#123;chunk, encoding&#125;);
    callback();
  &#125;

  _read () &#123;
    this._innerChunks.forEach(item =&gt; &#123;
      let upperCasedAlphabet = item.chunk.toString().toUpperCase();
      this.push(upperCasedAlphabet);
    &#125;);
    this.push(null); // end
  &#125;
&#125;

const dp = new DP();
dp.pipe(process.stdout);

dp.write(&#39;a&#39;);
dp.write(&#39;b&#39;);
dp.write(&#39;c&#39;);
dp.end();
</code></pre>
<p>相比 readstream、writestream，支持另外的配置参数：</p>
<ul>
<li>allowHalfOpen：默认是true。如果设置为false，当 read side 结束时，wirte side 也会被结束掉。</li>
<li>readableObjectMode：默认是false。设置read side的objectMode。</li>
<li>writableObjectMode：默认是false。设置write side的objectMode。</li>
<li>readableHighWaterMark：设置read side的highWaterMark。如果有 highWaterMark 设置项存在，这个设置项会被忽略。</li>
<li>writableHighWaterMark：设置write side的highWaterMark。如果有 highWaterMark 设置项存在，这个设置项会被忽略。</li>
</ul>
<h2 id="Transform-Stream"><a href="#Transform-Stream" class="headerlink" title="Transform Stream"></a>Transform Stream</h2><p>需要自定义 _transform()、_flush() 方法。代码如下：</p>
<pre><code class="javascript">const &#123; Transform &#125; = require(&#39;stream&#39;);

class TR extends Transform &#123;
  constructor (options = &#123;&#125;) &#123;
    super(options);
  &#125;

  _transform (chunk, encoding, callback) &#123;
    let upperCasedAlphabet = chunk.toString().toUpperCase();
    this.push(upperCasedAlphabet);
    callback();
  &#125;

  _flush (callback) &#123;
    this.push(&#39;!&#39;);
    callback();
  &#125;
&#125;

const tr = new TR();
// tr.pipe(process.stdout);
tr.on(&#39;data&#39;, (chunk) =&gt; console.log(`ondata: $&#123;chunk&#125;`));

tr.write(&#39;a&#39;);
tr.write(&#39;b&#39;);
tr.write(&#39;c&#39;);
tr.end();

// ondata: A
// ondata: B
// ondata: C
// ondata: !
</code></pre>
<h2 id="各种模式"><a href="#各种模式" class="headerlink" title="各种模式"></a>各种模式</h2><p>combine stream：<br><a target="_blank" rel="noopener" href="https://www.npmjs.org/package/multipipe">https://www.npmjs.org/package/multipipe</a><br><a target="_blank" rel="noopener" href="https://www.npmjs.com/package/combine-stream">https://www.npmjs.com/package/combine-stream</a></p>
<p>fork stream：</p>
<p>merge stream<br><a target="_blank" rel="noopener" href="https://www.npmjs.com/package/multistream">https://www.npmjs.com/package/multistream</a><br><a target="_blank" rel="noopener" href="https://npmjs.org/package/merge-stream">https://npmjs.org/package/merge-stream</a><br><a target="_blank" rel="noopener" href="https://npmjs.org/package/multistream-merge">https://npmjs.org/package/multistream-merge</a></p>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><h3 id="readSteram"><a href="#readSteram" class="headerlink" title="readSteram"></a>readSteram</h3><p>process.stdin.read() vs process.stdin.read(size) 在终端上的表现。</p>
<p>readable 事件触发，用户没有调用 read() 方法，会有什么影响？（丢失数据？还是数据保留在内部缓冲区，但新的数据不进去了？）</p>
<p>_read([size]) 方法，有没有传 size ，两者实现的区别？内部调用 push() 时，如果 返回 false，该如何处理？（返回false时，当前想push的data是否需要重新push？）</p>
<p>实现 Readable Stream，打印的 readable 有点不大对？</p>
<h3 id="write-stream"><a href="#write-stream" class="headerlink" title="write stream"></a>write stream</h3><p>write(chunk) 调用，如果写入的 chunk 太多，且远超过 backpressure 的值，会有什么影响（internal buffer 也容不下的情况）？</p>
<p>backpressure 对read stream、write stream 的影响。</p>
<h3 id="transform-stream"><a href="#transform-stream" class="headerlink" title="transform stream"></a>transform stream</h3><p>readstream.on(‘data’, fn) 与 readStream.pipe(stream) 的区别（）。多次调用 write()，on(‘data’) 输出会换行。pipe() 不会换行（参考 Transform Stream小节）</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Node.js Design Patterns</p>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2020-04-02T05:50:58.000Z" itemprop="datePublished">2020-04-02</time>
</div>
    
        <div class="article-category">
        <a class="article-category-link" href="/categories/Node-js/">Node.js</a>
        </div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-2020-05-文件上传-multer"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/article/2020/04/Node-js/2020-05-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0-multer.html">Node.js-buffer</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>图片上传是web开发中经常用到的功能，node社区在这方面也有了相对完善的支持。</p>
<p>常用的开源组件有<strong>multer</strong>、<strong>formidable</strong>等，借助这两个开源组件，可以轻松搞定图片上传。</p>
<p>本文主要讲解以下内容，后续章节会对技术实现细节进行深入挖掘。本文所有例子均有代码示例，可在<a href="../examples/2016.11.07-advanced-express-multer/">这里</a>查看。</p>
<ul>
<li>基础例子：借助express、multer实现单图、多图上传。</li>
<li>常用API：获取上传的图片的信息。</li>
<li>进阶使用：自定义保存的图片路径、名称。</li>
</ul>
<h2 id="环境初始化"><a href="#环境初始化" class="headerlink" title="环境初始化"></a>环境初始化</h2><p>非常简单，一行命令。</p>
<pre><code class="bash">npm install express multer multer --save
</code></pre>
<p>每个示例下面，都有下面两个文件</p>
<pre><code class="bash">➜  upload-custom-filename git:(master) ✗ tree -L 1
.
├── app.js # 服务端代码，用来处理文件上传请求
├── form.html # 前端页面，用来上传文件
</code></pre>
<h2 id="基础例子：单图上传"><a href="#基础例子：单图上传" class="headerlink" title="基础例子：单图上传"></a>基础例子：单图上传</h2><p>完整示例代码请参考<a href="../examples/2016.11.07-advanced-express-multer/upload-single">这里</a>。</p>
<p><a href="../examples/2016.11.07-advanced-express-multer/upload-single/app.js">app.js</a>。</p>
<pre><code class="javascript">var fs = require(&#39;fs&#39;);
var express = require(&#39;express&#39;);
var multer  = require(&#39;multer&#39;)

var app = express();
var upload = multer(&#123; dest: &#39;upload/&#39; &#125;);

// 单图上传
app.post(&#39;/upload&#39;, upload.single(&#39;logo&#39;), function(req, res, next)&#123;
    res.send(&#123;ret_code: &#39;0&#39;&#125;);
&#125;);

app.get(&#39;/form&#39;, function(req, res, next)&#123;
    var form = fs.readFileSync(&#39;./form.html&#39;, &#123;encoding: &#39;utf8&#39;&#125;);
    res.send(form);
&#125;);

app.listen(3000);
</code></pre>
<p><a href="../examples/2016.11.07-advanced-express-multer/upload-single/form.html">form.html</a>。</p>
<pre><code class="html">&lt;form action=&quot;/upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;
    &lt;h2&gt;单图上传&lt;/h2&gt;
    &lt;input type=&quot;file&quot; name=&quot;logo&quot;&gt;
    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;
&lt;/form&gt;
</code></pre>
<p>运行服务。</p>
<pre><code class="bash">node app.js
</code></pre>
<p>访问 <a target="_blank" rel="noopener" href="http://127.0.0.1:3000/form">http://127.0.0.1:3000/form</a> ，选择图片，点击“提交”，done。然后，你就会看到 upload 目录下多了个图片。</p>
<h2 id="基础例子：多图上传"><a href="#基础例子：多图上传" class="headerlink" title="基础例子：多图上传"></a>基础例子：多图上传</h2><p>完整示例代码请参考<a href="../examples/2016.11.07-advanced-express-multer/upload-multi">这里</a>。</p>
<p>代码简直不能更简单，将前面的 upload.single(‘logo’) 改成 upload.array(‘logo’, 2) 就行。表示：同时支持2张图片上传，并且 name 属性为 logo。</p>
<p><a href="../examples/2016.11.07-advanced-express-multer/upload-multi/app.js">app.js</a>。</p>
<pre><code class="javascript">var fs = require(&#39;fs&#39;);
var express = require(&#39;express&#39;);
var multer  = require(&#39;multer&#39;)

var app = express();
var upload = multer(&#123; dest: &#39;upload/&#39; &#125;);

// 多图上传
app.post(&#39;/upload&#39;, upload.array(&#39;logo&#39;, 2), function(req, res, next)&#123;
    res.send(&#123;ret_code: &#39;0&#39;&#125;);
&#125;);

app.get(&#39;/form&#39;, function(req, res, next)&#123;
    var form = fs.readFileSync(&#39;./form.html&#39;, &#123;encoding: &#39;utf8&#39;&#125;);
    res.send(form);
&#125;);

app.listen(3000);

</code></pre>
<p><a href="../examples/2016.11.07-advanced-express-multer/upload-multi/form.html">form.html</a>。</p>
<pre><code class="html">&lt;form action=&quot;/upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;
    &lt;h2&gt;多图上传&lt;/h2&gt;
    &lt;input type=&quot;file&quot; name=&quot;logos&quot;&gt;
    &lt;input type=&quot;file&quot; name=&quot;logos&quot;&gt;
    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;
&lt;/form&gt;
</code></pre>
<p>同样的测试步骤，不赘述。</p>
<h2 id="获取上传的图片的信息"><a href="#获取上传的图片的信息" class="headerlink" title="获取上传的图片的信息"></a>获取上传的图片的信息</h2><p>完整示例代码请参考<a href="../examples/2016.11.07-advanced-express-multer/upload-get-file-info">这里</a>。</p>
<p>很多时候，除了将图片保存在服务器外，我们还需要做很多其他事情，比如将图片的信息存到数据库里。</p>
<p>常用的信息比如原始文件名、文件类型、文件大小、本地保存路径等。借助multer，我们可以很方便的获取这些信息。</p>
<p>还是单文件上传的例子，此时，multer会将文件的信息写到 req.file 上，如下代码所示。</p>
<p><a href="../examples/2016.11.07-advanced-express-multer/upload-get-file-info/app.js">app.js</a>。</p>
<pre><code class="javascript">var fs = require(&#39;fs&#39;);
var express = require(&#39;express&#39;);
var multer  = require(&#39;multer&#39;)

var app = express();
var upload = multer(&#123; dest: &#39;upload/&#39; &#125;);

// 单图上传
app.post(&#39;/upload&#39;, upload.single(&#39;logo&#39;), function(req, res, next)&#123;
    var file = req.file;

    console.log(&#39;文件类型：%s&#39;, file.mimetype);
    console.log(&#39;原始文件名：%s&#39;, file.originalname);
    console.log(&#39;文件大小：%s&#39;, file.size);
    console.log(&#39;文件保存路径：%s&#39;, file.path);

    res.send(&#123;ret_code: &#39;0&#39;&#125;);
&#125;);

app.get(&#39;/form&#39;, function(req, res, next)&#123;
    var form = fs.readFileSync(&#39;./form.html&#39;, &#123;encoding: &#39;utf8&#39;&#125;);
    res.send(form);
&#125;);

app.listen(3000);
</code></pre>
<p><a href="../examples/2016.11.07-advanced-express-multer/upload-get-file-info/form.html">form.html</a>。</p>
<pre><code class="html">&lt;form action=&quot;/upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;
    &lt;h2&gt;单图上传&lt;/h2&gt;
    &lt;input type=&quot;file&quot; name=&quot;logo&quot;&gt;
    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;
&lt;/form&gt;
</code></pre>
<p>启动服务，上传文件后，就会看到控制台下打印出的信息。</p>
<pre><code class="bash">文件类型：image/png
原始文件名：1.png
文件大小：18379
文件保存路径：upload/b7e4bb22375695d92689e45b551873d9
</code></pre>
<h2 id="自定义文件上传路径、名称"><a href="#自定义文件上传路径、名称" class="headerlink" title="自定义文件上传路径、名称"></a>自定义文件上传路径、名称</h2><p>有的时候，我们想要定制文件上传的路径、名称，multer也可以方便的实现。</p>
<h3 id="自定义本地保存的路径"><a href="#自定义本地保存的路径" class="headerlink" title="自定义本地保存的路径"></a>自定义本地保存的路径</h3><p>非常简单，比如我们想将文件上传到 my-upload 目录下，修改下 dest 配置项就行。</p>
<pre><code class="javascript">var upload = multer(&#123; dest: &#39;upload/&#39; &#125;);
</code></pre>
<p>在上面的配置下，所有资源都是保存在同个目录下。有时我们需要针对不同文件进行个性化设置，那么，可以参考下一小节的内容。</p>
<h3 id="自定义本地保存的文件名"><a href="#自定义本地保存的文件名" class="headerlink" title="自定义本地保存的文件名"></a>自定义本地保存的文件名</h3><p>完整示例代码请参考<a href="../examples/2016.11.07-advanced-express-multer/upload-custom-filename">这里</a>。</p>
<p>代码稍微长一点，单同样简单。multer 提供了 <strong>storage</strong> 这个参数来对资源保存的路径、文件名进行个性化设置。</p>
<p>使用注意事项如下：</p>
<ul>
<li>destination：设置资源的保存路径。注意，如果没有这个配置项，默认会保存在 /tmp/uploads 下。此外，路径需要自己创建。</li>
<li>filename：设置资源保存在本地的文件名。</li>
</ul>
<p><a href="../examples/2016.11.07-advanced-express-multer/upload-custom-filename/app.js">app.js</a>。</p>
<pre><code class="javascript">var fs = require(&#39;fs&#39;);
var express = require(&#39;express&#39;);
var multer  = require(&#39;multer&#39;)

var app = express();

var createFolder = function(folder)&#123;
    try&#123;
        fs.accessSync(folder);
    &#125;catch(e)&#123;
        fs.mkdirSync(folder);
    &#125;
&#125;;

var uploadFolder = &#39;./upload/&#39;;

createFolder(uploadFolder);

// 通过 filename 属性定制
var storage = multer.diskStorage(&#123;
    destination: function (req, file, cb) &#123;
        cb(null, uploadFolder);    // 保存的路径，备注：需要自己创建
    &#125;,
    filename: function (req, file, cb) &#123;
        // 将保存文件名设置为 字段名 + 时间戳，比如 logo-1478521468943
        cb(null, file.fieldname + &#39;-&#39; + Date.now());
    &#125;
&#125;);

// 通过 storage 选项来对 上传行为 进行定制化
var upload = multer(&#123; storage: storage &#125;)

// 单图上传
app.post(&#39;/upload&#39;, upload.single(&#39;logo&#39;), function(req, res, next)&#123;
    var file = req.file;
    res.send(&#123;ret_code: &#39;0&#39;&#125;);
&#125;);

app.get(&#39;/form&#39;, function(req, res, next)&#123;
    var form = fs.readFileSync(&#39;./form.html&#39;, &#123;encoding: &#39;utf8&#39;&#125;);
    res.send(form);
&#125;);

app.listen(3000);
</code></pre>
<p><a href="../examples/2016.11.07-advanced-express-multer/upload-custom-filename/form.html">form.html</a>。</p>
<pre><code class="html">&lt;form action=&quot;/upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;
    &lt;h2&gt;单图上传&lt;/h2&gt;
    &lt;input type=&quot;file&quot; name=&quot;logo&quot;&gt;
    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;
&lt;/form&gt;
</code></pre>
<p>测试步骤不赘述，访问一下就知道效果了。</p>
<h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>本文对multer的基础用法进行了介绍，并未涉及过多原理性的东西。俗话说 <strong>授人以渔不如授人以渔</strong>，在后续的章节里，会对文件上传的细节进行挖掘，好让读者朋友对文件上传加深进一步的认识。</p>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p>multer官方文档：<a target="_blank" rel="noopener" href="https://github.com/expressjs/multer">https://github.com/expressjs/multer</a></p>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2020-04-02T05:50:58.000Z" itemprop="datePublished">2020-04-02</time>
</div>
    
        <div class="article-category">
        <a class="article-category-link" href="/categories/Node-js/">Node.js</a>
        </div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-2020-05-日志模块morgan"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/article/2020/04/Node-js/2020-05-%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97morgan.html">Node.js-buffer</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="章节概览"><a href="#章节概览" class="headerlink" title="章节概览"></a>章节概览</h2><p>morgan是express默认的日志中间件，也可以脱离express，作为node.js的日志组件单独使用。本文由浅入深，内容主要包括：</p>
<ul>
<li>morgan使用入门例子</li>
<li>如何将日志保存到本地文件</li>
<li>核心API使用说明及例子</li>
<li>进阶使用：1、日志分割 2、将日志写入数据库</li>
<li>源码剖析：morgan的日志格式以及预编译</li>
</ul>
<h2 id="入门例子"><a href="#入门例子" class="headerlink" title="入门例子"></a>入门例子</h2><p>首先，初始化项目。</p>
<pre><code class="bash">npm install express morgan
</code></pre>
<p>然后，在<code>basic.js</code>中添加如下代码。</p>
<pre><code class="js">var express = require(&#39;express&#39;);
var app = express();
var morgan = require(&#39;morgan&#39;);

app.use(morgan(&#39;short&#39;));
app.use(function(req, res, next)&#123;
    res.send(&#39;ok&#39;);
&#125;);

app.listen(3000);
</code></pre>
<p><code>node basic.js</code>运行程序，并在浏览器里访问 <a target="_blank" rel="noopener" href="http://127.0.0.1:3000/">http://127.0.0.1:3000</a> ，打印日志如下</p>
<pre><code class="bash">➜  2016.12.11-advanced-morgan git:(master) ✗ node basic.js
::ffff:127.0.0.1 - GET / HTTP/1.1 304 - - 3.019 ms
::ffff:127.0.0.1 - GET /favicon.ico HTTP/1.1 200 2 - 0.984 ms
</code></pre>
<h2 id="将日志打印到本地文件"><a href="#将日志打印到本地文件" class="headerlink" title="将日志打印到本地文件"></a>将日志打印到本地文件</h2><p>morgan支持stream配置项，可以通过它来实现将日志落地的效果，代码如下：</p>
<pre><code class="js">var express = require(&#39;express&#39;);
var app = express();
var morgan = require(&#39;morgan&#39;);
var fs = require(&#39;fs&#39;);
var path = require(&#39;path&#39;);

var accessLogStream = fs.createWriteStream(path.join(__dirname, &#39;access.log&#39;), &#123;flags: &#39;a&#39;&#125;);

app.use(morgan(&#39;short&#39;, &#123;stream: accessLogStream&#125;));
app.use(function(req, res, next)&#123;
    res.send(&#39;ok&#39;);
&#125;);

app.listen(3000);
</code></pre>
<h2 id="使用讲解"><a href="#使用讲解" class="headerlink" title="使用讲解"></a>使用讲解</h2><h3 id="核心API"><a href="#核心API" class="headerlink" title="核心API"></a>核心API</h3><p>morgan的API非常少，使用频率最高的就是<code>morgan()</code>，作用是返回一个express日志中间件。</p>
<pre><code class="js">morgan(format, options)
</code></pre>
<p>参数说明如下：</p>
<ul>
<li>format：可选，morgan与定义了几种日志格式，每种格式都有对应的名称，比如<code>combined</code>、<code>short</code>等，默认是<code>default</code>。不同格式的差别可参考<a target="_blank" rel="noopener" href="https://github.com/expressjs/morgan/#predefined-formats">这里</a>。下文会讲解下，如果自定义日志格式。</li>
<li>options：可选，配置项，包含<code>stream（常用）</code>、<code>skip</code>、<code>immediate</code>。<ul>
<li>stream：日志的输出流配置，默认是<code>process.stdout</code>。</li>
<li>skip：是否跳过日志记录，使用方式可以参考<a target="_blank" rel="noopener" href="https://github.com/expressjs/morgan/#skip">这里</a>。</li>
<li>immediate：布尔值，默认是false。当为true时，一收到请求，就记录日志；如果为false，则在请求返回后，再记录日志。</li>
</ul>
</li>
</ul>
<h3 id="自定义日志格式"><a href="#自定义日志格式" class="headerlink" title="自定义日志格式"></a>自定义日志格式</h3><p>首先搞清楚morgan中的两个概念：format 跟 token。非常简单：</p>
<ul>
<li>format：日志格式，本质是代表日志格式的字符串，比如 <code>:method :url :status :res[content-length] - :response-time ms</code>。</li>
<li>token：format的组成部分，比如上面的<code>:method</code>、<code>:url</code>即使所谓的token。</li>
</ul>
<p>搞清楚format、token的区别后，就可以看下morgan中，关于自定义日志格式的关键API。</p>
<pre><code class="js">morgan.format(name, format);  // 自定义日志格式
morgan.token(name, fn);  // 自定义token
</code></pre>
<h2 id="自定义format"><a href="#自定义format" class="headerlink" title="自定义format"></a>自定义format</h2><p>非常简单，首先通过<code>morgan.format()</code>定义名为<code>joke</code>的日志格式，然后通过<code>morgan(&#39;joke&#39;)</code>调用即可。</p>
<pre><code class="js">var express = require(&#39;express&#39;);
var app = express();
var morgan = require(&#39;morgan&#39;);

morgan.format(&#39;joke&#39;, &#39;[joke] :method :url :status&#39;);

app.use(morgan(&#39;joke&#39;));

app.use(function(req, res, next)&#123;
    res.send(&#39;ok&#39;);
&#125;);

app.listen(3000);
</code></pre>
<p>我们来看下运行结果</p>
<pre><code class="bash">➜  2016.12.11-advanced-morgan git:(master) ✗ node morgan.format.js
[joke] GET / 304
[joke] GET /favicon.ico 200
</code></pre>
<h2 id="自定义token"><a href="#自定义token" class="headerlink" title="自定义token"></a>自定义token</h2><p>代码如下，通过<code>morgan.token()</code>自定义token，然后将自定义的token，加入自定义的format中即可。</p>
<pre><code class="js">var express = require(&#39;express&#39;);
var app = express();
var morgan = require(&#39;morgan&#39;);

// 自定义token
morgan.token(&#39;from&#39;, function(req, res)&#123;
    return req.query.from || &#39;-&#39;;
&#125;);

// 自定义format，其中包含自定义的token
morgan.format(&#39;joke&#39;, &#39;[joke] :method :url :status :from&#39;);

// 使用自定义的format
app.use(morgan(&#39;joke&#39;));

app.use(function(req, res, next)&#123;
    res.send(&#39;ok&#39;);
&#125;);

app.listen(3000);
</code></pre>
<p>运行程序，并在浏览器里先后访问 <a target="_blank" rel="noopener" href="http://127.0.0.1:3000/hello?from=app">http://127.0.0.1:3000/hello?from=app</a> 和 <a target="_blank" rel="noopener" href="http://127.0.0.1:3000/hello?from=pc">http://127.0.0.1:3000/hello?from=pc</a></p>
<pre><code class="bash">➜  2016.12.11-advanced-morgan git:(master) ✗ node morgan.token.js
[joke] GET /hello?from=app 200 app
[joke] GET /favicon.ico 304 -
[joke] GET /hello?from=pc 200 pc
[joke] GET /favicon.ico 304 -
</code></pre>
<h2 id="高级使用"><a href="#高级使用" class="headerlink" title="高级使用"></a>高级使用</h2><h3 id="日志切割"><a href="#日志切割" class="headerlink" title="日志切割"></a>日志切割</h3><p>一个线上应用，如果所有的日志都落地到同一个本地文件，时间久了，文件会变得非常大，既影响性能，又不便于查看。这时候，就需要用到日志分割了。</p>
<p>借助<code>file-stream-rotator</code>插件，可以轻松完成日志分割的工作。除了<code>file-stream-rotator</code>相关的配置代码，其余跟之前的例子差不多，这里不赘述。</p>
<pre><code class="js">var FileStreamRotator = require(&#39;file-stream-rotator&#39;)
var express = require(&#39;express&#39;)
var fs = require(&#39;fs&#39;)
var morgan = require(&#39;morgan&#39;)
var path = require(&#39;path&#39;)

var app = express()
var logDirectory = path.join(__dirname, &#39;log&#39;)

// ensure log directory exists
fs.existsSync(logDirectory) || fs.mkdirSync(logDirectory)

// create a rotating write stream
var accessLogStream = FileStreamRotator.getStream(&#123;
  date_format: &#39;YYYYMMDD&#39;,
  filename: path.join(logDirectory, &#39;access-%DATE%.log&#39;),
  frequency: &#39;daily&#39;,
  verbose: false
&#125;)

// setup the logger
app.use(morgan(&#39;combined&#39;, &#123;stream: accessLogStream&#125;))

app.get(&#39;/&#39;, function (req, res) &#123;
  res.send(&#39;hello, world!&#39;)
&#125;)
</code></pre>
<h3 id="日志写入数据库"><a href="#日志写入数据库" class="headerlink" title="日志写入数据库"></a>日志写入数据库</h3><p>有的时候，我们会有这样的需求，将访问日志写入数据库。这种需求常见于需要实时查询统计的日志系统。</p>
<p>在morgan里该如何实现呢？从文档上，并没有看到适合的扩展接口。于是查阅了下<code>morgan</code>的源码，发现实现起来非常简单。</p>
<p>回顾下之前日志写入本地文件的例子，最关键的两行代码如下。通过<code>stream</code>指定日志的输出流。</p>
<pre><code class="js">var accessLogStream = fs.createWriteStream(path.join(__dirname, &#39;access.log&#39;), &#123;flags: &#39;a&#39;&#125;);
app.use(morgan(&#39;short&#39;, &#123;stream: accessLogStream&#125;));
</code></pre>
<p>在<code>morgan</code>内部，大致实现是这样的（简化后）。</p>
<pre><code class="js">// opt为配置文件
var stream = opts.stream || process.stdout;
var logString = createLogString();  // 伪代码，根据format、token的定义，生成日志
stream.write(logString);
</code></pre>
<p>于是，可以用比较取巧的方式来实现目的：声明一个带<code>write</code>方法的对象，并作为<code>stream</code>配置传入。</p>
<pre><code class="js">var express = require(&#39;express&#39;);
var app = express();
var morgan = require(&#39;morgan&#39;);

// 带write方法的对象
var dbStream = &#123;
  write: function(line)&#123;
    saveToDatabase(line);  // 伪代码，保存到数据库
  &#125;
&#125;;

// 将 dbStream 作为 stream 配置项的值
app.use(morgan(&#39;short&#39;, &#123;stream: dbStream&#125;));
app.use(function(req, res, next)&#123;
  res.send(&#39;ok&#39;);
&#125;);

app.listen(3000);
</code></pre>
<h2 id="深入剖析"><a href="#深入剖析" class="headerlink" title="深入剖析"></a>深入剖析</h2><p>morgan的代码非常简洁，从设计上来说，morgan的生命周期包含：</p>
<blockquote>
<p>token定义 –&gt; 日志格式定义 -&gt; 日志格式预编译 –&gt; 请求达到/返回 –&gt; 写日志</p>
</blockquote>
<p>其中，token定义、日志格式定义前面已经讲到，这里就只讲下 <strong>日志格式预编译</strong> 的细节。</p>
<p>跟模板引擎预编译一样，日志格式预编译，也是为了提升性能。源码如下，最关键的代码就是<code>compile(fmt)</code>。</p>
<pre><code class="js">function getFormatFunction (name) &#123;
  // lookup format
  var fmt = morgan[name] || name || morgan.default

  // return compiled format
  return typeof fmt !== &#39;function&#39;
    ? compile(fmt)
    : fmt
&#125;
</code></pre>
<p><code>compile()</code>方法的实现细节这里不赘述，着重看下<code>compile(fmt)</code>返回的内容：</p>
<pre><code class="js">var morgan = require(&#39;morgan&#39;);
var format = morgan[&#39;tiny&#39;];
var fn = morgan.compile(format);

console.log(fn.toString());
</code></pre>
<p>运行上面程序，输出内容如下，其中<code>tokens</code>其实就是<code>morgan</code>。</p>
<pre><code class="bash">function anonymous(tokens, req, res
/**/) &#123;
  return &quot;&quot;
    + (tokens[&quot;method&quot;](req, res, undefined) || &quot;-&quot;) + &quot; &quot;
    + (tokens[&quot;url&quot;](req, res, undefined) || &quot;-&quot;) + &quot; &quot;
    + (tokens[&quot;status&quot;](req, res, undefined) || &quot;-&quot;) + &quot; &quot;
    + (tokens[&quot;res&quot;](req, res, &quot;content-length&quot;) || &quot;-&quot;) + &quot; - &quot;
    + (tokens[&quot;response-time&quot;](req, res, undefined) || &quot;-&quot;) + &quot; ms&quot;;
&#125;
</code></pre>
<p>看下<code>morgan.token()</code>的定义，就很清晰了</p>
<pre><code class="js">function token (name, fn) &#123;
  morgan[name] = fn
  return this
&#125;
</code></pre>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a target="_blank" rel="noopener" href="https://github.com/expressjs/morgan">https://github.com/expressjs/morgan</a></p>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2020-04-02T05:50:58.000Z" itemprop="datePublished">2020-04-02</time>
</div>
    
        <div class="article-category">
        <a class="article-category-link" href="/categories/Node-js/">Node.js</a>
        </div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-2020-05-图片地址转成datauri"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/article/2020/04/Node-js/2020-05-%E5%9B%BE%E7%89%87%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%88%90datauri.html">Node.js-buffer</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="将图片转成datauri"><a href="#将图片转成datauri" class="headerlink" title="将图片转成datauri"></a>将图片转成datauri</h2><p>nodejs读取图片，转成base64,也就是把图片转成对应的datauri,这是个很常用的功能。快速实现了个简单的demo，这里顺便记录一下。</p>
        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2020-04-02T05:50:58.000Z" itemprop="datePublished">2020-04-02</time>
</div>
    
        <div class="article-category">
        <a class="article-category-link" href="/categories/Node-js/">Node.js</a>
        </div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-2020-04-child-process"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/article/2020/04/Node-js/2020-04-child-process.html">Node.js-child_process</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="模块概览"><a href="#模块概览" class="headerlink" title="模块概览"></a>模块概览</h2><p>在node中，child_process这个模块非常重要。掌握了它，等于在node的世界开启了一扇新的大门。</p>
        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2020-04-02T05:50:58.000Z" itemprop="datePublished">2020-04-02</time>
</div>
    
        <div class="article-category">
        <a class="article-category-link" href="/categories/Node-js/">Node.js</a>
        </div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-2020-04-fs"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/article/2020/04/Node-js/2020-04-fs.html">Node.js-fs</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h2><h3 id="普通读取"><a href="#普通读取" class="headerlink" title="普通读取"></a>普通读取</h3><p>同步读取</p>
<pre><code class="javascript">var fs = require(&#39;fs&#39;);
var data;

try&#123;
    data = fs.readFileSync(&#39;./fileForRead.txt&#39;, &#39;utf8&#39;);
    console.log(&#39;文件内容: &#39; + data);
&#125;catch(err)&#123;
    console.error(&#39;读取文件出错: &#39; + err.message);
&#125;
</code></pre>
<p>输出如下：</p>
<pre><code class="powershell">/usr/local/bin/node readFileSync.js
文件内容: hello world
</code></pre>
<p>异步读取</p>
<pre><code class="javascript">var fs = require(&#39;fs&#39;);

fs.readFile(&#39;./fileForRead.txt&#39;, &#39;utf8&#39;, function(err, data)&#123;
    if(err)&#123;
        return console.error(&#39;读取文件出错: &#39; + err.message);
    &#125;
    console.log(&#39;文件内容: &#39; + data);
&#125;);
</code></pre>
<p>输出如下</p>
<pre><code class="powershell">/usr/local/bin/node readFile.js
文件内容: hello world
</code></pre>
<h3 id="通过文件流读取"><a href="#通过文件流读取" class="headerlink" title="通过文件流读取"></a>通过文件流读取</h3><p>适合读取大文件</p>
<pre><code class="javascript">var fs = require(&#39;fs&#39;);
var readStream = fs.createReadStream(&#39;./fileForRead.txt&#39;, &#39;utf8&#39;);

readStream
    .on(&#39;data&#39;, function(chunk) &#123;
        console.log(&#39;读取数据: &#39; + chunk);
    &#125;)
    .on(&#39;error&#39;, function(err)&#123;
        console.log(&#39;出错: &#39; + err.message);
    &#125;)
    .on(&#39;end&#39;, function()&#123;  // 没有数据了
        console.log(&#39;没有数据了&#39;);
    &#125;)
    .on(&#39;close&#39;, function()&#123;  // 已经关闭，不会再有事件抛出
        console.log(&#39;已经关闭&#39;);
    &#125;);
</code></pre>
<p>输出如下</p>
<pre><code class="powershell">/usr/local/bin/node createReadStream.js
读取数据: hello world
没有数据了
已经关闭
</code></pre>
<h2 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h2><p>备注：以下代码，如果文件不存在，则创建文件；如果文件存在，则覆盖文件内容；</p>
<p>异步写入</p>
<pre><code class="javascript">var fs = require(&#39;fs&#39;);

fs.writeFile(&#39;./fileForWrite.txt&#39;, &#39;hello world&#39;, &#39;utf8&#39;, function(err)&#123;
    if(err) throw err;
    console.log(&#39;文件写入成功&#39;);
&#125;);
</code></pre>
<p>同步写入</p>
<pre><code class="javascript">var fs = require(&#39;fs&#39;);

try&#123;
    fs.writeFileSync(&#39;./fileForWrite1.txt&#39;, &#39;hello world&#39;, &#39;utf8&#39;);
    console.log(&#39;文件写入成功&#39;);
&#125;catch(err)&#123;
    throw err;
&#125;
</code></pre>
<h3 id="通过文件流写入"><a href="#通过文件流写入" class="headerlink" title="通过文件流写入"></a>通过文件流写入</h3><pre><code class="javascript">var fs = require(&#39;fs&#39;);
var writeStream = fs.createWriteStream(&#39;./fileForWrite1.txt&#39;, &#39;utf8&#39;);

writeStream
    .on(&#39;close&#39;, function()&#123;  // 已经关闭，不会再有事件抛出
        console.log(&#39;已经关闭&#39;);
    &#125;);

writeStream.write(&#39;hello&#39;);
writeStream.write(&#39;world&#39;);
writeStream.end(&#39;&#39;);
</code></pre>
<h3 id="相对底层的接口"><a href="#相对底层的接口" class="headerlink" title="相对底层的接口"></a>相对底层的接口</h3><blockquote>
<p>fs.write(fd, buffer, offset, length[, position], callback)<br>fs.write(fd, data[, position[, encoding]], callback)<br>fs.writeSync(fd, buffer, offset, length[, position])<br>fs.writeSync(fd, data[, position[, encoding]])</p>
</blockquote>
<ul>
<li>fd：写入的文件句柄。</li>
<li>buffer：写入的内容。</li>
<li>offset：将buffer从offset位置开始，长度为length的内容写入。</li>
<li>length：写入的buffer内容的长度。</li>
<li>position：从打开文件的position处写入。</li>
<li>callback：参数为 <code>(err, written, buffer)</code>。<code>written</code>表示有xx字节的buffer被写入。</li>
</ul>
<p>备注：<code>fs.write(fd, buffer, offset, length[, position], callback)</code>跟<code>fs.write(fd, data[, position[, encoding]], callback)</code>的区别在于：后面的只能把所有的data写入，而前面的可以写入指定的data子串？</p>
<h2 id="文件是否存在"><a href="#文件是否存在" class="headerlink" title="文件是否存在"></a>文件是否存在</h2><p><code>fs.exists()</code>已经是<code>deprecated</code>状态，现在可以通过下面代码判断文件是否存在。</p>
<pre><code class="javascript">var fs = require(&#39;fs&#39;);

fs.access(&#39;./fileForRead.txt&#39;, function(err)&#123;
    if(err) throw err;
    console.log(&#39;fileForRead.txt存在&#39;);
&#125;);

fs.access(&#39;./fileForRead2.txt&#39;, function(err)&#123;
    if(err) throw err;
    console.log(&#39;fileForRead2.txt存在&#39;);
&#125;);
</code></pre>
<p><code>fs.access()</code>除了判断文件是否存在（默认模式），还可以用来判断文件的权限。</p>
<p>备忘：<code>fs.constants.F_OK</code>等常量无法获取（node v6.1，mac 10.11.4下，<code>fs.constants</code>是<code>undefined</code>）</p>
<h2 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h2><p>异步版本（如果目录已存在，会报错）</p>
<pre><code class="javascript">var fs = require(&#39;fs&#39;);

fs.mkdir(&#39;./hello&#39;, function(err)&#123;
    if(err) throw err;
    console.log(&#39;目录创建成功&#39;);
&#125;);
</code></pre>
<p>同步版本</p>
<pre><code class="javascript">var fs = require(&#39;fs&#39;);

fs.mkdirSync(&#39;./hello&#39;);
</code></pre>
<h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><pre><code class="javascript">var fs = require(&#39;fs&#39;);

fs.unlink(&#39;./fileForUnlink.txt&#39;, function(err)&#123;
    if(err) throw err;
    console.log(&#39;文件删除成功&#39;);
&#125;);
</code></pre>
<pre><code class="javascript">var fs = require(&#39;fs&#39;);

fs.unlinkSync(&#39;./fileForUnlink.txt&#39;);
</code></pre>
<h2 id="创建目录-1"><a href="#创建目录-1" class="headerlink" title="创建目录"></a>创建目录</h2><pre><code class="javascript">// fs.mkdir(path[, mode], callback)
var fs = require(&#39;fs&#39;);

fs.mkdir(&#39;sub&#39;, function(err)&#123;
    if(err) throw err;
    console.log(&#39;创建目录成功&#39;);
&#125;);
</code></pre>
<pre><code class="javascript">// fs.mkdirSync(path[, mode])
var fs = require(&#39;fs&#39;);

try&#123;
    fs.mkdirSync(&#39;hello&#39;);
    console.log(&#39;创建目录成功&#39;);
&#125;catch(e)&#123;
    throw e;
&#125;
</code></pre>
<h2 id="遍历目录"><a href="#遍历目录" class="headerlink" title="遍历目录"></a>遍历目录</h2><p>同步版本，注意：<code>fs.readdirSync()</code>只会读一层，所以需要判断文件类型是否目录，如果是，则进行递归遍历。</p>
<pre><code class="javascript">// fs.readdirSync(path[, options])

var fs = require(&#39;fs&#39;);
var path = require(&#39;path&#39;);

var getFilesInDir = function(dir)&#123;

    var results = [ path.resolve(dir) ];
    var files = fs.readdirSync(dir, &#39;utf8&#39;);

    files.forEach(function(file)&#123;

        file = path.resolve(dir, file);

        var stats = fs.statSync(file);

        if(stats.isFile())&#123;
            results.push(file);
        &#125;else if(stats.isDirectory())&#123;
            results = results.concat( getFilesInDir(file) );
        &#125;
    &#125;);

    return results;
&#125;;

var files = getFilesInDir(&#39;../&#39;);
console.log(files);
</code></pre>
<p>异步版本：（TODO）</p>
<pre><code class="javascript">
</code></pre>
<h2 id="文件重命名"><a href="#文件重命名" class="headerlink" title="文件重命名"></a>文件重命名</h2><pre><code class="javascript">// fs.rename(oldPath, newPath, callback)
var fs = require(&#39;fs&#39;);

fs.rename(&#39;./hello&#39;, &#39;./world&#39;, function(err)&#123;
    if(err) throw err;
    console.log(&#39;重命名成功&#39;);
&#125;);
</code></pre>
<pre><code class="javascript">fs.renameSync(oldPath, newPath)
var fs = require(&#39;fs&#39;);

fs.renameSync(&#39;./world&#39;, &#39;./hello&#39;);
</code></pre>
<h2 id="监听文件修改"><a href="#监听文件修改" class="headerlink" title="监听文件修改"></a>监听文件修改</h2><p><code>fs.watch()</code>比<code>fs.watchFile()</code>高效很多（why）</p>
<h3 id="fs-watchFile"><a href="#fs-watchFile" class="headerlink" title="fs.watchFile()"></a>fs.watchFile()</h3><p>实现原理：轮询。每隔一段时间检查文件是否发生变化。所以在不同平台上表现基本是一致的。</p>
<pre><code class="javascript">var fs = require(&#39;fs&#39;);

var options = &#123;
    persistent: true,  // 默认就是true
    interval: 2000  // 多久检查一次
&#125;;

// curr, prev 是被监听文件的状态, fs.Stat实例
// 可以通过 fs.unwatch() 移除监听
fs.watchFile(&#39;./fileForWatch.txt&#39;, options, function(curr, prev)&#123;
    console.log(&#39;修改时间为: &#39; + curr.mtime);
&#125;);
</code></pre>
<p>修改<code>fileForWatch.txt</code>，可以看到控制台下打印出日志</p>
<pre><code class="powershell">/usr/local/bin/node watchFile.js
修改时间为: Sat Jul 16 2016 19:03:57 GMT+0800 (CST)
修改时间为: Sat Jul 16 2016 19:04:05 GMT+0800 (CST)
</code></pre>
<p>为啥子？莫非单纯访问文件也会触发回调？</p>
<blockquote>
<p>If you want to be notified when the file was modified, not just accessed, you need to compare curr.mtime and prev.mtime.</p>
</blockquote>
<p>在 <strong>v0.10</strong> 之后的改动。如果监听的文件不存在，会怎么处理。如下</p>
<blockquote>
<p>Note: when an fs.watchFile operation results in an ENOENT error, it will invoke the listener once, with all the fields zeroed (or, for dates, the Unix Epoch). In Windows, blksize and blocks fields will be undefined, instead of zero. If the file is created later on, the listener will be called again, with the latest stat objects. This is a change in functionality since v0.10.</p>
</blockquote>
<h3 id="fs-watch"><a href="#fs-watch" class="headerlink" title="fs.watch()"></a>fs.watch()</h3><blockquote>
<p>fs.watch(filename[, options][, listener])<br>fs.unwatchFile(filename[, listener])</p>
</blockquote>
<p>这接口非常不靠谱（当前测试用的v6.1.0），参考 <a target="_blank" rel="noopener" href="https://github.com/nodejs/node/issues/7420">https://github.com/nodejs/node/issues/7420</a></p>
<blockquote>
<p>fs.watch(filename[, options][, listener])#</p>
</blockquote>
<p>注意：<code>fs.watch()</code>这个接口并不是在所有的平台行为都一致，并且在某些情况下是不可用的。<code>recursive</code>这个选项只在<code>mac</code>、<code>windows</code>下可用。</p>
<p>问题来了：</p>
<ol>
<li>不一致的表现。</li>
<li>不可用的场景。</li>
<li>linux上要recursive咋整。</li>
</ol>
<blockquote>
<p>The fs.watch API is not 100% consistent across platforms, and is unavailable in some situations.<br>The recursive option is only supported on OS X and Windows.</p>
</blockquote>
<p>备忘，不可用的场景。比如网络文件系统等。</p>
<blockquote>
<p>For example, watching files or directories can be unreliable, and in some cases impossible, on network file systems (NFS, SMB, etc), or host file systems when using virtualization software such as Vagrant, Docker, etc.</p>
</blockquote>
<p>另外，listener回调有两个参数，分别是<code>event</code>、<code>filename</code>。其中，<code>filename</code>仅在linux、windows上会提供，并且不是100%提供，所以，尽量不要依赖<code>filename</code>。</p>
<p>在linux、osx上，<code>fs.watch()</code>监听的是inode。如果文件被删除，并重新创建，那么删除事件会触发。同时，<code>fs.watch()</code>监听的还是最初的inode。（API的设计就是这样的）</p>
<p>结论：怎么看都感觉这个API很不靠谱，虽然性能比fs.watchFile()要高很多。</p>
<p>先来个例子，在osx下测试了一下，简直令人绝望。。。无论是创建、修改、删除文件，<code>evt</code>都是<code>rename</code>。。。</p>
<pre><code class="javascript">var fs = require(&#39;fs&#39;);

var options = &#123;
    persistent: true,
    recursive: true,
    encoding: &#39;utf8&#39;
&#125;;

fs.watch(&#39;../&#39;, options, function(event, filename)&#123;
    console.log(&#39;触发事件:&#39; + event);
    if(filename)&#123;
        console.log(&#39;文件名是: &#39; + filename);
    &#125;else&#123;
        console.log(&#39;文件名是没有提供&#39;);
    &#125;
&#125;);
</code></pre>
<p>修改下<code>fileForWatch.txt</code>，看到下面输出。。。感觉打死也不想用这个API。。。</p>
<p>贴下环境：osx 10.11.4, node v6.1.0。</p>
<pre><code class="powershell">触发事件:rename
文件名是: fs/fileForWatch.txt___jb_bak___
触发事件:rename
文件名是: fs/fileForWatch.txt
触发事件:rename
文件名是: fs/fileForWatch.txt___jb_old___
触发事件:rename
文件名是: .idea/workspace.xml___jb_bak___
触发事件:rename
文件名是: .idea/workspace.xml
触发事件:rename
文件名是: .idea/workspace.xml___jb_old___
</code></pre>
<h2 id="修改所有者"><a href="#修改所有者" class="headerlink" title="修改所有者"></a>修改所有者</h2><p>参考linux命令行，不举例子了。。。</p>
<blockquote>
<p>fs.chown(path, uid, gid, callback)<br>fs.chownSync(path, uid, gid)<br>fs.fchown(fd, uid, gid, callback)<br>fs.fchownSync(fd, uid, gid)</p>
</blockquote>
<h2 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h2><p>可以用<code>fs.chmod()</code>，也可以用<code>fs.fchmod()</code>。两者的区别在于，前面传的是文件路径，后面传的的文件句柄。</p>
<ol>
<li><code>fs.chmod)</code>、<code>fs.fchmod()</code>区别：传的是文件路径，还是文件句柄。</li>
<li><code>fs.chmod()</code>、<code>fs.lchmod()</code>区别：如果文件是软连接，那么<code>fs.chmod()</code>修改的是软连接指向的目标文件；<code>fs.lchmod()</code>修改的是软连接。</li>
</ol>
<blockquote>
<p>fs.chmod(path, mode, callback)<br>fs.chmodSync(path, mode)</p>
</blockquote>
<blockquote>
<p>fs.fchmod(fd, mode, callback)<br>fs.fchmodSync(fd, mode)</p>
</blockquote>
<blockquote>
<p>fs.lchmod(path, mode, callback)#<br>fs.lchmodSync(path, mode)</p>
</blockquote>
<p>例子：</p>
<pre><code class="javascript">var fs = require(&#39;fs&#39;);

fs.chmod(&#39;./fileForChown.txt&#39;, &#39;777&#39;, function(err)&#123;
    if(err) console.log(err);
    console.log(&#39;权限修改成功&#39;);
&#125;);
</code></pre>
<p>同步版本：</p>
<pre><code>var fs = require(&#39;fs&#39;);

fs.chmodSync(&#39;./fileForChown.txt&#39;, &#39;777&#39;);
</code></pre>
<h2 id="获取文件状态"><a href="#获取文件状态" class="headerlink" title="获取文件状态"></a>获取文件状态</h2><p>区别：</p>
<ul>
<li><code>fs.stat()</code> vs <code>fs.fstat()</code>：传文件路径 vs 文件句柄。</li>
<li><code>fs.stat()</code> vs <code>fs.lstat()</code>：如果文件是软链接，那么<code>fs.stat()</code>返回目标文件的状态，<code>fs.lstat()</code>返回软链接本身的状态。</li>
</ul>
<blockquote>
<p>fs.stat(path, callback)<br>fs.statSync(path)</p>
</blockquote>
<blockquote>
<p>fs.fstat(fd, callback)<br>fs.fstatSync(fd)</p>
</blockquote>
<blockquote>
<p>fs.lstat(path, callback)<br>fs.lstatSync(path)</p>
</blockquote>
<p>主要关注<code>Class: fs.Stats</code>。</p>
<p>首先是方法</p>
<ul>
<li>stats.isFile()  – 是否文件</li>
<li>stats.isDirectory() – 是否目录</li>
<li>stats.isBlockDevice() – 什么鬼</li>
<li>stats.isCharacterDevice() – 什么鬼</li>
<li>stats.isSymbolicLink() (only valid with fs.lstat()) – 什么鬼</li>
<li>stats.isFIFO() – 什么鬼</li>
<li>stats.isSocket() – 是不是socket文件</li>
</ul>
<p>官网例子：</p>
<pre><code class="javascript">&#123;
  dev: 2114,
  ino: 48064969,
  mode: 33188,
  nlink: 1,
  uid: 85,
  gid: 100,
  rdev: 0,
  size: 527,
  blksize: 4096,
  blocks: 8,
  atime: Mon, 10 Oct 2011 23:24:11 GMT, // 访问时间
  mtime: Mon, 10 Oct 2011 23:24:11 GMT,  // 文件内容修改时间
  ctime: Mon, 10 Oct 2011 23:24:11 GMT,  // 文件状态修改时间
  birthtime: Mon, 10 Oct 2011 23:24:11 GMT  // 创建时间
&#125;
</code></pre>
<ul>
<li>atime：Access Time // 访问时间</li>
<li>mtime:: Modified Time  // 文件内容修改时间</li>
<li>ctime: Changed Time.  // 文件状态修改时间，比如修改文件所有者、修改权限、重命名等</li>
<li>birthtime: Birth Time // 创建时间。在某些系统上是不可靠的，因为拿不到。</li>
</ul>
<p>例子：</p>
<pre><code class="javascript">var fs = require(&#39;fs&#39;);

var getTimeDesc = function(d)&#123;
    return [d.getFullYear(), d.getMonth()+1, d.getDate()].join(&#39;-&#39;) + &#39; &#39; + [d.getHours(), d.getMinutes(), d.getSeconds()].join(&#39;:&#39;);
&#125;;

fs.stat(&#39;./fileForStat.txt&#39;, function(err, stats)&#123;
    console.log(&#39;文件大小: &#39; + stats.size);
    console.log(&#39;创建时间: &#39; + getTimeDesc(stats.birthtime));
    console.log(&#39;访问时间: &#39; + getTimeDesc(stats.atime));
    console.log(&#39;修改时间: &#39; + getTimeDesc(stats.mtime));
&#125;);
</code></pre>
<p>输出如下：</p>
<pre><code class="powershell">/usr/local/bin/node stat.js
文件大小: 3613
创建时间: 2016-7-16 12:40:49
访问时间: 2016-7-16 12:40:49
修改时间: 2016-7-16 12:40:49

Process finished with exit code 0
</code></pre>
<p>同步的例子：</p>
<pre><code class="javascript">var fs = require(&#39;fs&#39;);

var getTimeDesc = function(d)&#123;
    return [d.getFullYear(), d.getMonth()+1, d.getDate()].join(&#39;-&#39;) + &#39; &#39; + [d.getHours(), d.getMinutes(), d.getSeconds()].join(&#39;:&#39;);
&#125;;

var stats = fs.statSync(&#39;./fileForStat.txt&#39;);

console.log(&#39;文件大小: &#39; + stats.size);
console.log(&#39;创建时间: &#39; + getTimeDesc(stats.birthtime));
console.log(&#39;访问时间: &#39; + getTimeDesc(stats.atime));
console.log(&#39;修改时间: &#39; + getTimeDesc(stats.mtime));
</code></pre>
<h2 id="访问-权限检测"><a href="#访问-权限检测" class="headerlink" title="访问/权限检测"></a>访问/权限检测</h2><p>例子：</p>
<pre><code class="javascript">// fs.access(path[, mode], callback)
var fs = require(&#39;fs&#39;);

fs.access(&#39;./fileForAccess.txt&#39;, function(err)&#123;
    if(err) throw err;
    console.log(&#39;可以访问&#39;);
&#125;);
</code></pre>
<p>同步版本：</p>
<pre><code class="javascript">// fs.accessSync(path[, mode])
var fs = require(&#39;fs&#39;);

// 如果成功，则返回undefined，如果失败，则抛出错误（什么鬼）
try&#123;
    fs.accessSync(&#39;./fileForAccess.txt&#39;);
&#125;catch(e)&#123;
    throw(e);
&#125;
</code></pre>
<h2 id="文件打开-关闭"><a href="#文件打开-关闭" class="headerlink" title="文件打开/关闭"></a>文件打开/关闭</h2><p>比较底层的接口，实际需要用到的机会不多。需要用到的时候看下<a target="_blank" rel="noopener" href="https://nodejs.org/api/fs.html#fs_fs_open_path_flags_mode_callback">文档</a>就行。</p>
<ul>
<li>flags：文件打开模式，比如<code>r</code>、<code>r+</code>、<code>w</code>、<code>w+</code>等。可选模式非常多。</li>
<li>mode：默认是<code>666</code>，可读+可写。</li>
</ul>
<blockquote>
<p>fs.open(path, flags[, mode], callback)<br>fs.openSync(path, flags[, mode])<br>fs.close(fd, callback)<br>fs.closeSync(fd)</p>
</blockquote>
<h2 id="文件读取（底层）"><a href="#文件读取（底层）" class="headerlink" title="文件读取（底层）"></a>文件读取（底层）</h2><p>相对底层的读取接口，参数如下</p>
<ul>
<li>fd：文件句柄。</li>
<li>buffer：将读取的文件内容写到buffer里。</li>
<li>offset：buffer开始写入的位置。（在offset开始写入，还是offset+1？）</li>
<li>length：要读取的字节数。</li>
<li>position：文件从哪个位置开始读取。如果是null，那么就从当前位置开始读取。（读取操作会记录下上一个位置）</li>
</ul>
<p>此外，<code>callback</code>的回调参数为<code>(err, bytesRead, buffer)</code></p>
<blockquote>
<p>fs.read(fd, buffer, offset, length, position, callback)</p>
</blockquote>
<h2 id="追加文件内容"><a href="#追加文件内容" class="headerlink" title="追加文件内容"></a>追加文件内容</h2><blockquote>
<p>fs.appendFile(file, data[, options], callback)</p>
</blockquote>
<ul>
<li>file：可以是文件路径，也可以是文件句柄。（还可以是buffer？）</li>
<li>data：要追加的内容。string或者buffer。</li>
<li>options<ul>
<li>encoding：编码，默认是<code>utf8</code></li>
<li>mode：默认是<code>0o666</code></li>
<li>flag：默认是<code>a</code></li>
</ul>
</li>
</ul>
<p>注意：如果<code>file</code>是文件句柄，那么</p>
<ul>
<li>开始追加数据前，file需要已经打开。</li>
<li>file需要手动关闭。</li>
</ul>
<pre><code class="javascript">var fs = require(&#39;fs&#39;);

fs.appendFile(&#39;./extra/fileForAppend.txt&#39;, &#39;hello&#39;, &#39;utf8&#39;, function(err)&#123;
    if(err) throw err;
    console.log(&#39;append成功&#39;);
&#125;);
</code></pre>
<h2 id="文件内容截取"><a href="#文件内容截取" class="headerlink" title="文件内容截取"></a>文件内容截取</h2><blockquote>
<p>fs.truncate(path, len, callback)<br>fs.truncateSync(path, len)</p>
<p>fs.ftruncate(fd, len, callback)<br>fs.ftruncateSync(fd, len)</p>
</blockquote>
<p>用途参考<a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/ftruncate.2.html">linux说明文档</a>。</p>
<p>要点：</p>
<ul>
<li><code>offset</code>不会变化。比如通过<code>fs.read()</code>读取文件内容，就需要特别注意。</li>
<li>如果<code>len</code>小于文件内容长度，剩余文件内容部分会丢失；如果<code>len</code>大于文件内容长度，那么超出的部分，会用<code>\0</code>进行填充。</li>
<li>如果传的是文件路径，需要确保文件是可写的；如果传的是文件句柄，需要确保文件句柄已经打开并且可写入。</li>
</ul>
<blockquote>
<p>The truncate() and ftruncate() functions cause the regular file named<br>by path or referenced by fd to be truncated to a size of precisely<br>length bytes.</p>
</blockquote>
<blockquote>
<p>If the file previously was larger than this size, the extra data is<br>lost.  If the file previously was shorter, it is extended, and the<br>extended part reads as null bytes (‘\0’).</p>
</blockquote>
<blockquote>
<p>The file offset is not changed.</p>
</blockquote>
<blockquote>
<p>With ftruncate(), the file must be open for writing; with truncate(), the file must be writable.</p>
</blockquote>
<h2 id="修改文件属性（时间）"><a href="#修改文件属性（时间）" class="headerlink" title="修改文件属性（时间）"></a>修改文件属性（时间）</h2><ul>
<li>path/fd：文件路径/文件句柄</li>
<li>atime：Access Time。上一次访问文件数据的时间。</li>
<li>mtime：Modified Time。修改时间。</li>
</ul>
<blockquote>
<p>fs.utimes(path, atime, mtime, callback)<br>fs.utimesSync(path, atime, mtime)</p>
</blockquote>
<blockquote>
<p>fs.futimes(fd, atime, mtime, callback)<br>fs.futimesSync(fd, atime, mtime)</p>
</blockquote>
<p>备注，在命令行下可以</p>
<ul>
<li>通过<code>stat</code>查看文件的状态信息，包括了上面的atime、mtime。</li>
<li>通过<code>touch</code>修改这几个时间。</li>
</ul>
<h2 id="创建文件链接"><a href="#创建文件链接" class="headerlink" title="创建文件链接"></a>创建文件链接</h2><blockquote>
<p>fs.symlink(target, path[, type], callback)<br>fs.symlinkSync(target, path[, type])</p>
<p>fs.link(srcpath, dstpath, callback)<br>fs.linkSync(srcpath, dstpath)</p>
</blockquote>
<blockquote>
<p> link() creates a new link (also known as a hard link) to an existing file.</p>
</blockquote>
<p>软链接、硬链接区别：<a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/">参考</a> 或者 [这个]。(<a target="_blank" rel="noopener" href="http://www.cnblogs.com/itech/archive/2009/04/10/1433052.html">http://www.cnblogs.com/itech/archive/2009/04/10/1433052.html</a>)</p>
<ul>
<li>硬链接：inode相同，多个别名。删除一个硬链接文件，不会影响其他有相同inode的文件。</li>
<li>软链接：有自己的inode，用户数据块存放指向文件的inode。</li>
</ul>
<p>参考<a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/link.2.html">这里</a>。</p>
<h2 id="创建临时目录"><a href="#创建临时目录" class="headerlink" title="创建临时目录"></a>创建临时目录</h2><blockquote>
<p>fs.mkdtemp(prefix, callback)<br>fs.mkdtempSync(prefix)</p>
</blockquote>
<p>备忘：跟普通的随便找个目录，创建个随机名字的文件夹，有什么区别？</p>
<p>代码示例如下：</p>
<pre><code class="javascript">var fs = require(&#39;fs&#39;);

fs.mkdtemp(&#39;/tmp/&#39;, function(err, folder)&#123;
    if(err) throw err;
    console.log(&#39;创建临时目录: &#39; + folder);
&#125;);
</code></pre>
<p>输出如下：</p>
<pre><code class="powershell">/usr/local/bin/node mkdtemp.js
创建临时目录: /tmp/Cxw51O
</code></pre>
<h2 id="找出软连接指向的真实路径"><a href="#找出软连接指向的真实路径" class="headerlink" title="找出软连接指向的真实路径"></a>找出软连接指向的真实路径</h2><blockquote>
<p>fs.readlink(path[, options], callback)<br>fs.readlinkSync(path[, options])</p>
</blockquote>
<p>如下面例子，创建了个软链接指向<code>fileForReadLink.txt</code>，通过<code>fs.readlink()</code>就可以找出原始的路径。</p>
<pre><code class="javascript">var fs = require(&#39;fs&#39;);
var randomFileName = &#39;./extra/fileForReadLink-&#39; + String(Math.random()).slice(2, 6) + &#39;.txt&#39;;

fs.symlinkSync(&#39;./extra/fileForReadLink.txt&#39;, randomFileName);
fs.readlink(randomFileName, &#39;utf8&#39;, function(err, linkString)&#123;
    if(err) throw err;
    console.log(&#39;链接文件内容: &#39; + linkString);
&#125;);
</code></pre>
<p>类似终端下直接运行<code>readlink</code>。对于软链接文件，效果同上面代码。对于硬链接，没有输出。</p>
<pre><code class="powershell">➜  extra git:(master) ✗ readlink fileForReadLink-9827.txt
./extra/fileForReadLink.txt
➜  extra git:(master) ✗ readlink fileForLinkHard.txt
➜  extra git:(master) ✗ readlink fileForLinkSoft.txt
./extra/fileForLink.txt
</code></pre>
<h2 id="真实路径"><a href="#真实路径" class="headerlink" title="真实路径"></a>真实路径</h2><blockquote>
<p>fs.realpath(path[, options], callback)<br>fs.realpathSync(path[, options])</p>
</blockquote>
<p>例子：（不能作用于软链接？）</p>
<pre><code class="javascript">var fs = require(&#39;fs&#39;);
var path = require(&#39;path&#39;);

// fileForRealPath1.txt 是普通文件,正常运行
fs.realpath(&#39;./extra/inner/fileForRealPath1.txt&#39;, function(err, resolvedPath)&#123;
    if(err) throw err;
    console.log(&#39;fs.realpath: &#39; + resolvedPath);
&#125;);

// fileForRealPath.txt 是软链接, 会报错,提示找不到文件
fs.realpath(&#39;./extra/inner/fileForRealPath.txt&#39;, function(err, resolvedPath)&#123;
    if(err) throw err;
    console.log(&#39;fs.realpath: &#39; + resolvedPath);
&#125;);

console.log( &#39;path.resolve: &#39; + path.resolve(&#39;./extra/inner/fileForRealpath.txt&#39;) );
</code></pre>
<p>输出如下：</p>
<pre><code class="powershell">path.resolve: /Users/a/Documents/git-code/git-blog/demo/2015.05.21-node-basic/fs/extra/inner/fileForRealpath.txt
fs.realpath: /Users/a/Documents/git-code/git-blog/demo/2015.05.21-node-basic/fs/extra/inner/fileForRealPath1.txt
/Users/a/Documents/git-code/git-blog/demo/2015.05.21-node-basic/fs/realpath.js:12
    if(err) throw err;
            ^

Error: ENOENT: no such file or directory, realpath &#39;./extra/inner/fileForRealPath.txt&#39;
    at Error (native)

Process finished with exit code 1
</code></pre>
<h2 id="删除目录"><a href="#删除目录" class="headerlink" title="删除目录"></a>删除目录</h2><blockquote>
<p>fs.rmdir(path, callback)<br>fs.rmdirSync(path)</p>
</blockquote>
<p>例子如下：</p>
<pre><code class="javascript">var fs = require(&#39;fs&#39;);

fs.rmdir(&#39;./dirForRemove&#39;, function(err)&#123;
    if(err) throw err;
    console.log(&#39;目录删除成功&#39;);
&#125;);
</code></pre>
<h2 id="不常用"><a href="#不常用" class="headerlink" title="不常用"></a>不常用</h2><h3 id="缓冲区内容写到磁盘"><a href="#缓冲区内容写到磁盘" class="headerlink" title="缓冲区内容写到磁盘"></a>缓冲区内容写到磁盘</h3><blockquote>
<p>fs.fdatasync(fd, callback)<br>fs.fdatasyncSync(fd)</p>
</blockquote>
<p>可以参考这里：</p>
<blockquote>
<p>1、sync函数<br>sync函数只是将所有修改过的块缓冲区排入写队列，然后就返回，它并不等待实际写磁盘操作结束。<br>通常称为update的系统守护进程会周期性地（一般每隔30秒）调用sync函数。这就保证了定期冲洗内核的块缓冲区。命令sync(1)也调用sync函数。<br>2、fsync函数<br>fsync函数只对由文件描述符filedes指定的单一文件起作用，并且等待写磁盘操作结束，然后返回。<br>fsync可用于数据库这样的应用程序，这种应用程序需要确保将修改过的块立即写到磁盘上。<br>3、fdatasync函数<br>fdatasync函数类似于fsync，但它只影响文件的数据部分。而除数据外，fsync还会同步更新文件的属性。<br>对于提供事务支持的数据库，在事务提交时，都要确保事务日志（包含该事务所有的修改操作以及一个提交记录）完全写到硬盘上，才认定事务提交成功并返回给应用层。</p>
</blockquote>
<h2 id="待确认"><a href="#待确认" class="headerlink" title="待确认"></a>待确认</h2><ol>
<li>通篇的<code>mode</code>，待确认。</li>
<li>fs.access()更多用法（涉及 fs.constants.F_OK等权限）</li>
</ol>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2020-04-02T05:50:58.000Z" itemprop="datePublished">2020-04-02</time>
</div>
    
        <div class="article-category">
        <a class="article-category-link" href="/categories/Node-js/">Node.js</a>
        </div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-2020-05-cluster"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/article/2020/04/Node-js/2020-05-cluster.html">Node.js-buffer</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>下文适合对cluster模块有一定了解的同学阅读。主要包含两部分内容：</p>
<ol>
<li>cluster模块如何实现端口共享</li>
<li>cluster模块如何分发请求</li>
</ol>
<h2 id="端口共享源码分析"><a href="#端口共享源码分析" class="headerlink" title="端口共享源码分析"></a>端口共享源码分析</h2><p>首先，master 进程 fork() 子进程：</p>
<pre><code class="javascript">// master进程
cluster.fork()
</code></pre>
<p>子进程创建 net.Server 实例：</p>
<pre><code class="javascript">// worker进程
require(&#39;net&#39;).createServer(() =&gt; &#123;&#125;).listen(3000);
</code></pre>
<p>在 net 模块中，调用 cluster._getServer</p>
<pre><code class="javascript">// worker进程
cluster._getServer(self, &#123;
  address: address,
  port: port,
  addressType: addressType,
  fd: fd,
  flags: 0
&#125;, cb);

function cb(err, handle) &#123;
  // 忽略错误处理
  self._handle = handle;
  self._listen2(address, port, addressType, backlog, fd);
&#125;
</code></pre>
<p>在 cluster._getServer 中，通过 process.send(message)，向 master 进程发送 queryServer 请求。</p>
<pre><code class="javascript">// worker进程
cluster._getServer = function(obj, options, cb) &#123;
    const indexesKey = [ options.address,
                         options.port,
                         options.addressType,
                         options.fd ].join(&#39;:&#39;);
    if (indexes[indexesKey] === undefined)
      indexes[indexesKey] = 0;
    else
      indexes[indexesKey]++;

    // message =&gt;
    // &#123;
    //   act: &#39;queryServer&#39;,
    //   index: &#39;:3000:4:&#39;,
    //   data: null,
    //   address: null,
    //   port: 3000,
    //   addressType: 4,
    //   fd: undefined
    // &#125;
    const message = util._extend(&#123;
      act: &#39;queryServer&#39;,
      index: indexes[indexesKey],
      data: null
    &#125;, options);

    // Set custom data on handle (i.e. tls tickets key)
    if (obj._getServerData) message.data = obj._getServerData();

    /*
      send 方法的定义如下，注意：masterInit 里也有 send 方法
      function send(message, cb) &#123;
        return sendHelper(process, message, null, cb);
      &#125;
      在 sendHelper 里对 message 进程加工，最终 message 如下所示（关键字段）：
      &#123; cmd: &#39;NODE_CLUSTER&#39;, act: &#39;queryServer&#39; &#125;
    */
    send(message, function(reply, handle) &#123;
      if (obj._setServerData) obj._setServerData(reply.data);

      if (handle)
        shared(reply, handle, indexesKey, cb);  // Shared listen socket.
      else
        rr(reply, indexesKey, cb);              // Round-robin.
    &#125;);

    obj.once(&#39;listening&#39;, function() &#123;
      cluster.worker.state = &#39;listening&#39;;
      const address = obj.address();
      message.act = &#39;listening&#39;;
      message.port = address &amp;&amp; address.port || options.port;
      send(message);
    &#125;);
  &#125;;
</code></pre>
<p>在 cluster.fork() 方法里，监听了 internalMessage 事件，onmessage里，调用了 queryServer()。</p>
<pre><code class="javascript">// master进程
cluster.fork = function(env) &#123;
  // 忽略非关键代码
  const workerProcess = createWorkerProcess(id, env);
  const worker = new Worker(&#123;
    id: id,
    process: workerProcess
  &#125;);
  worker.process.on(&#39;internalMessage&#39;, internal(worker, onmessage));
&#125;;

//
function onmessage(message, handle) &#123;
  var worker = this;
  if (message.act === &#39;online&#39;)
    online(worker);
  else if (message.act === &#39;queryServer&#39;)
    // 调用 queryServer 方法
    queryServer(worker, message);
  else if (message.act === &#39;listening&#39;)
    listening(worker, message);
  else if (message.act === &#39;exitedAfterDisconnect&#39;)
    exitedAfterDisconnect(worker, message);
  else if (message.act === &#39;close&#39;)
    close(worker, message);
&#125;
</code></pre>
<p>在 queryServer 里，首先 创建 RoundRobinHandle 实例，然后调用 handle.add()。</p>
<p>对于 address + port + addressType + fd + index 一样的 net.Server 实例，只创建一个 RoundRobinHandle 实例，并通过 handle.add() 将worker添加进去。</p>
<pre><code class="javascript">// master进程
function queryServer(worker, message) &#123;
    var args = [message.address,
                message.port,
                message.addressType,
                message.fd, // undefined
                message.index]; // 注意：对于同样的监听参数，index 是从0开始递增的整数
    var key = args.join(&#39;:&#39;); // 例子：&#39;:3000:4::0&#39;
    var handle = handles[key];
    if (handle === undefined) &#123;
      var constructor = RoundRobinHandle;

      // 创建新的handle，并挂载到 handles 上
      // 这里的 constructor 为 RoundRobinHandle
      handles[key] = handle = new constructor(key,
                                              message.address,
                                              message.port,
                                              message.addressType,
                                              message.fd,
                                              message.flags);
    &#125;
    if (!handle.data) handle.data = message.data;

    // Set custom server data
    handle.add(worker, function(errno, reply, handle) &#123;
      reply = util._extend(&#123;
        errno: errno,
        key: key,
        ack: message.seq,
        data: handles[key].data
      &#125;, reply);
      if (errno) delete handles[key];  // Gives other workers a chance to retry.
      send(worker, reply, handle);
    &#125;);
  &#125;
</code></pre>
<p>看下 RoundRobinHandle 的构造方法。创建了 net.Server 实例，并调用 server.listen() 方法（实际监听）。</p>
<p>当 listening 事件触发，将 onconnection 事件覆盖掉，实现在多个worker中分发请求的逻辑。</p>
<pre><code class="javascript">// master进程
function RoundRobinHandle(key, address, port, addressType, fd) &#123;
  this.key = key;
  this.all = &#123;&#125;;
  this.free = [];
  this.handles = [];
  this.handle = null;
  this.server = net.createServer(assert.fail);

  if (fd &gt;= 0)
    this.server.listen(&#123; fd: fd &#125;);
  else if (port &gt;= 0)
    this.server.listen(port, address);
  else
    this.server.listen(address);  // UNIX socket path.

  this.server.once(&#39;listening&#39;, () =&gt; &#123;
    this.handle = this.server._handle;
    // 监听 connection 事件，当用户请求进来时，通过 this.distribute() 分发请求到各个worker
    this.handle.onconnection = (err, handle) =&gt; this.distribute(err, handle);
    this.server._handle = null;
    this.server = null;
  &#125;);
&#125;
</code></pre>
<p>注意，前面调用了 handle.add() 方法，如下所示</p>
<pre><code class="javascript">// master进程
// Set custom server data
handle.add(worker, function(errno, reply, handle) &#123;
  reply = util._extend(&#123;
    errno: errno,
    key: key,
    ack: message.seq,
    data: handles[key].data
  &#125;, reply);
  if (errno) delete handles[key];  // Gives other workers a chance to retry.
  send(worker, reply, handle);
&#125;);
</code></pre>
<p>看下方法定义（忽略非主要逻辑）：</p>
<pre><code class="javascript">// master进程
RoundRobinHandle.prototype.add = function(worker, send) &#123;
  // 存储worker的引用
  this.all[worker.id] = worker;

  // 当listening事件触发，done 被调用（注意，在 RoundRobinHandle 构造方法里也监听了 listening）
  const done = () =&gt; &#123;
    if (this.handle.getsockname) &#123;
      // osx 10.13.1，node 8.9.3，跑这个分支
      var out = &#123;&#125;;
      this.handle.getsockname(out);
      // 这里的 send 函数名比较有歧义，其实是 handle.add(worker, callback) 中的 callback
      // TODO(bnoordhuis) Check err.
      send(null, &#123; sockname: out &#125;, null);
    &#125; else &#123;
      send(null, null, null);  // UNIX socket.
    &#125;
    this.handoff(worker);  // In case there are connections pending.
  &#125;;

  // Still busy binding.
  this.server.once(&#39;listening&#39;, done);
&#125;;
</code></pre>
<p>当 listening 事件触发，下面方法被调用。同样的，最终被 sendHelper 封装了一遍</p>
<pre><code class="javascript">// master进程
// error: null
// reply: &#123;&#125;
// handle: null
function(errno, reply, handle) &#123;
  reply = util._extend(&#123;
    errno: errno,
    key: key,
    ack: message.seq,
    data: handles[key].data
  &#125;, reply);
  if (errno) delete handles[key];  // Gives other workers a chance to retry.
  &#123;&quot;errno&quot;:null,&quot;key&quot;:&quot;:3000:4::0&quot;,&quot;ack&quot;:1,&quot;data&quot;:null,&quot;sockname&quot;:&#123;&quot;address&quot;:&quot;::&quot;,&quot;family&quot;:&quot;IPv6&quot;,&quot;port&quot;:3000&#125;&#125;
  send(worker, reply, handle);
&#125;
</code></pre>
<p>经过 sendHelper 的封装，worker.process.send(message)，message 内容如下。注意，此时 ack === 1。</p>
<pre><code class="javascript">// master进程
&#123;
  &quot;cmd&quot;: &quot;NODE_CLUSTER&quot;,
  &quot;sockname&quot;: &#123;
    &quot;address&quot;: &quot;::&quot;,
    &quot;family&quot;: &quot;IPv6&quot;,
    &quot;port&quot;: 3000
  &#125;,
  &quot;data&quot;: null,
  &quot;ack&quot;: 1,
  &quot;key&quot;: &quot;:3000:4::0&quot;,
  &quot;errno&quot;: null,
  &quot;seq&quot;: 0
&#125;
</code></pre>
<p>当上面 message 被发出时，worker 进程的 internalMessage 事件触发。（worker进程 的internalMessage 事件是在 node_bootstrap阶段监听的，这里容易忽略）</p>
<pre><code class="javascript">// worker进程
cluster._setupWorker = function() &#123;
  var worker = new Worker(&#123;
    id: +process.env.NODE_UNIQUE_ID | 0,
    process: process,
    state: &#39;online&#39;
  &#125;);
  cluster.worker = worker;
  process.on(&#39;internalMessage&#39;, internal(worker, onmessage));
&#125;;
</code></pre>
<p>如下所示，当 message.ack 存在时，callbacks[message.ack] 被调用。</p>
<pre><code class="javascript">// worker进程
function internal(worker, cb) &#123;
  return function(message, handle) &#123;
    if (message.cmd !== &#39;NODE_CLUSTER&#39;) return;
    var fn = cb;
    // 此时，message.ack === 1
    // callbacks[message.ack] 是 _getServer 的回调
    if (message.ack !== undefined &amp;&amp; callbacks[message.ack] !== undefined) &#123;
      fn = callbacks[message.ack];
      delete callbacks[message.ack];
    &#125;
    fn.apply(worker, arguments);
  &#125;;
&#125;
</code></pre>
<p>也就是下面的回调。</p>
<pre><code class="javascript">// worker进程
// obj is a net#Server or a dgram#Socket object.
cluster._getServer = function(obj, options, cb) &#123;

  // 忽略部分代码
  const message = util._extend(&#123;
    act: &#39;queryServer&#39;,
    index: indexes[indexesKey],
    data: null
  &#125;, options);

  /*
  注意：就是这里的回调】
  reply: &#123;
    &quot;cmd&quot;: &quot;NODE_CLUSTER&quot;,
    &quot;sockname&quot;: &#123;
      &quot;address&quot;: &quot;::&quot;,
      &quot;family&quot;: &quot;IPv6&quot;,
      &quot;port&quot;: 3000
    &#125;,
    &quot;data&quot;: null,
    &quot;ack&quot;: 1,
    &quot;key&quot;: &quot;:3000:4::0&quot;,
    &quot;errno&quot;: null,
    &quot;seq&quot;: 0
  &#125;
  handle：undefined
  */
  send(message, (reply, handle) =&gt; &#123;
    if (handle)
      shared(reply, handle, indexesKey, cb);  // Shared listen socket.
    else
      // 这里被调用
      rr(reply, indexesKey, cb);              // Round-robin.
  &#125;);
&#125;;
</code></pre>
<p>下面是 rr 方法的定义。</p>
<pre><code class="javascript">// worker进程
// message： &#123;&quot;cmd&quot;:&quot;NODE_CLUSTER&quot;,&quot;sockname&quot;:&#123;&quot;address&quot;:&quot;::&quot;,&quot;family&quot;:&quot;IPv6&quot;,&quot;port&quot;:3000&#125;,&quot;data&quot;:null,&quot;ack&quot;:1,&quot;key&quot;:&quot;:3000:4::0&quot;,&quot;errno&quot;:null,&quot;seq&quot;:0&#125;
// indexsKey: &quot;:3000:4:&quot;
// cb: _getServer 的回调
// Round-robin. Master distributes handles across workers.
function rr(message, indexesKey, cb) &#123;
  if (message.errno)
    return cb(message.errno, null);

  var key = message.key;
  function listen(backlog) &#123;
    // TODO(bnoordhuis) Send a message to the master that tells it to
    // update the backlog size. The actual backlog should probably be
    // the largest requested size by any worker.
    return 0;
  &#125;

  function close() &#123;
    // lib/net.js treats server._handle.close() as effectively synchronous.
    // That means there is a time window between the call to close() and
    // the ack by the master process in which we can still receive handles.
    // onconnection() below handles that by sending those handles back to
    // the master.
    if (key === undefined) return;
    send(&#123; act: &#39;close&#39;, key: key &#125;);
    delete handles[key];
    delete indexes[indexesKey];
    key = undefined;
  &#125;

  function getsockname(out) &#123;
    if (key) util._extend(out, message.sockname);
    return 0;
  &#125;

  // XXX(bnoordhuis) Probably no point in implementing ref() and unref()
  // because the control channel is going to keep the worker alive anyway.
  function ref() &#123;
  &#125;

  function unref() &#123;
  &#125;

  // Faux handle. Mimics a TCPWrap with just enough fidelity to get away
  // with it. Fools net.Server into thinking that it&#39;s backed by a real
  // handle.
  var handle = &#123;
    close: close,
    listen: listen,
    ref: ref,
    unref: unref,
  &#125;;
  if (message.sockname) &#123;
    handle.getsockname = getsockname;  // TCP handles only.
  &#125;

  handles[key] = handle;
  cb(0, handle); // 终于调用 cb 了。。。
&#125;
</code></pre>
<p>然后，下面的回调函数被调用：</p>
<pre><code class="javascript">// worker进程
function cb(err, handle) &#123;
  // err：0
  // handle: &#123;close: fn, listen: fn, getsockname: fn, ref: fn, unref: fn&#125;
  if (err === 0 &amp;&amp; port &gt; 0 &amp;&amp; handle.getsockname) &#123;
    var out = &#123;&#125;;
    err = handle.getsockname(out);
    if (err === 0 &amp;&amp; port !== out.port)
      err = uv.UV_EADDRINUSE;
  &#125;

  self._handle = handle; // 将 handle 赋给 net.Server 实例
  self._listen2(address, port, addressType, backlog, fd); // 调用 _listen2 方法
&#125;
</code></pre>
<p>看下此时 _listen2 做了什么。主要是抛出 listening 事件，以及 添加 onconnection 监听。</p>
<pre><code class="javascript">// worker进程
Server.prototype._listen2 = function(address, port, addressType, backlog, fd) &#123;

  // If there is not yet a handle, we need to create one and bind.
  // In the case of a server sent via IPC, we don&#39;t need to do this.
  if (this._handle) &#123;
    debug(&#39;_listen2: have a handle already&#39;);
  &#125;

  this._handle.onconnection = onconnection; // onconnect 回调
  this._handle.owner = this;

  var err = _listen(this._handle, backlog);

  // generate connection key, this should be unique to the connection
  this._connectionKey = addressType + &#39;:&#39; + address + &#39;:&#39; + port;

  process.nextTick(emitListeningNT, this);
&#125;;
</code></pre>
<p>前面说过，在主进程里，创建了 net.Server 实例，并对端口进行实际的监听。再来回顾这段代码</p>
<pre><code class="javascript">// master进程
// Start a round-robin server. Master accepts connections and distributes
// them over the workers.
function RoundRobinHandle(key, address, port, addressType, fd) &#123;
  // 忽略非重点代码
  this.server = net.createServer(assert.fail);
  this.server.listen(port, address); // 注意这里的监听

  this.server.once(&#39;listening&#39;, () =&gt; &#123;
    this.handle = this.server._handle;
    this.handle.onconnection = (err, handle) =&gt; this.distribute(err, handle);
    this.server._handle = null;
    this.server = null;
  &#125;);
&#125;
</code></pre>
<p>监听调用的是 net 模块中如下函数：</p>
<pre><code class="javascript">// master进程
self._listen2(address, port, addressType, backlog, fd);
</code></pre>
<pre><code class="javascript">// master进程
Server.prototype._listen2 = function(address, port, addressType, backlog, fd) &#123;

  // If there is not yet a handle, we need to create one and bind.
  // In the case of a server sent via IPC, we don&#39;t need to do this.
  // 此时，this._handle 是 null（初始化状态），于是走第二个分支
  if (this._handle) &#123;
    debug(&#39;_listen2: have a handle already&#39;);
  &#125; else &#123;
    debug(&#39;_listen2: create a handle&#39;);

    var rval = null;

    if (!address &amp;&amp; typeof fd !== &#39;number&#39;) &#123;
      rval = createServerHandle(&#39;::&#39;, port, 6, fd);

      if (typeof rval === &#39;number&#39;) &#123;
        rval = null;
        address = &#39;0.0.0.0&#39;;
        addressType = 4;
      &#125; else &#123;
        address = &#39;::&#39;;
        addressType = 6;
      &#125;
    &#125;

    // rval: &#123;&quot;reading&quot;:false,&quot;owner&quot;:null,&quot;onread&quot;:null,&quot;onconnection&quot;:null,&quot;writeQueueSize&quot;:0&#125;
    if (rval === null)
      // 重点是这行代码，在这里面创建 TCP 实例，并进行监听
      // fd: undefined
      // address: ::&#39;&#39;
      rval = createServerHandle(address, port, addressType, fd);

    if (typeof rval === &#39;number&#39;) &#123;
      var error = exceptionWithHostPort(rval, &#39;listen&#39;, address, port);
      process.nextTick(emitErrorNT, this, error);
      return;
    &#125;
    this._handle = rval;
  &#125;

  this._handle.onconnection = onconnection;
  this._handle.owner = this;

  var err = _listen(this._handle, backlog);

  if (err) &#123;
    var ex = exceptionWithHostPort(err, &#39;listen&#39;, address, port);
    this._handle.close();
    this._handle = null;
    process.nextTick(emitErrorNT, this, ex);
    return;
  &#125;

  // generate connection key, this should be unique to the connection
  this._connectionKey = addressType + &#39;:&#39; + address + &#39;:&#39; + port;

  // unref the handle if the server was unref&#39;ed prior to listening
  if (this._unref)
    this.unref();

  process.nextTick(emitListeningNT, this);
&#125;;
</code></pre>
<p>主要逻辑：创建 TCP 实例，绑定端口、IP，并返回 handle。</p>
<pre><code class="javascript">//master进程
function createServerHandle(address, port, addressType, fd) &#123;
  var err = 0;
  // assign handle in listen, and clean up if bind or listen fails
  var handle;

  var isTCP = false;

  handle = new TCP();
  isTCP = true;

  if (address || port || isTCP) &#123;
    debug(&#39;bind to &#39; + (address || &#39;anycast&#39;));
    if (!address) &#123;
      // Try binding to ipv6 first
      err = handle.bind6(&#39;::&#39;, port);
      if (err) &#123;
        handle.close();
        // Fallback to ipv4
        return createServerHandle(&#39;0.0.0.0&#39;, port);
      &#125;
    &#125; else if (addressType === 6) &#123;
      err = handle.bind6(address, port);
    &#125; else &#123;
      err = handle.bind(address, port);
    &#125;
  &#125;

  if (err) &#123;
    handle.close();
    return err;
  &#125;

  return handle;
&#125;
</code></pre>
<p>server._handle 初始化完成，开始监听后，触发 listening 事件。此时，RoundRobinHandle 中的回调函数被调用。</p>
<pre><code class="javascript">// master进程
this.server.once(&#39;listening&#39;, () =&gt; &#123;
  // 将 this.server._handle 赋值给 this.handle
  this.handle = this.server._handle;
  // 覆盖 this.handle.onconnection，以达到请求分发的目的
  this.handle.onconnection = (err, handle) =&gt; this.distribute(err, handle);
  // 将server._handle 设置为null
  this.server._handle = null;
  // 将this.server 设置为null（这里只需要 handle 就够了）
  this.server = null;
&#125;);
</code></pre>
<p>经过上面的复杂流程，最终的结果是：</p>
<ol>
<li>master 进程中创建了 net.Server 实例A，并对来自特定端口的请求进行监听。</li>
<li>worker 进程中创建了 net.Server 实例B。</li>
<li>当新连接创建时，实例A 将请求分发给实例B。（如果有多个worker进程，master进程会按照特定算法进行分发）</li>
</ol>
<h2 id="请求分发源码分析"><a href="#请求分发源码分析" class="headerlink" title="请求分发源码分析"></a>请求分发源码分析</h2><p>首先，当连接请求进来时，调用 this.distribute(err, handle);</p>
<pre><code class="javascript">// master进程
this.handle.onconnection = (err, handle) =&gt; this.distribute(err, handle);
</code></pre>
<p>看下distribute的实现。主要做了两件事情：</p>
<ol>
<li>将 handle 加入待处理队列。</li>
<li>取得第一个空闲的worker，如果存在，就调用 this.handoff(worker); 处理请求。</li>
</ol>
<pre><code class="javascript">// master进程
RoundRobinHandle.prototype.distribute = function(err, handle) &#123;
  // 将 handle 加入 handles 队列，该队列里是待处理的请求对应的handle。
  this.handles.push(handle);
  // 取第一个空闲的worker
  var worker = this.free.shift();
  // 如果有空闲的worker
  if (worker) this.handoff(worker);
&#125;;
</code></pre>
<p>看下 handoff(worker) 的实现。</p>
<pre><code class="javascript">// master进程
RoundRobinHandle.prototype.handoff = function(worker) &#123;
  if (worker.id in this.all === false) &#123;
    return;  // Worker is closing (or has closed) the server.
  &#125;
  // 获取第一个待处理的请求
  var handle = this.handles.shift();
  if (handle === undefined) &#123;
    this.free.push(worker);  // Add to ready queue again.
    return;
  &#125;
  var message = &#123; act: &#39;newconn&#39;, key: this.key &#125;;

  // 向worker进程发送消息
  // message：&#123; act: &#39;newconn&#39;, key: this.key &#125;
  sendHelper(worker.process, message, handle, (reply) =&gt; &#123;
    // 当 worker进程 收到消息后，ack回应，调用 handle.close()
    if (reply.accepted)
      handle.close();
    else
      this.distribute(0, handle);  // Worker is shutting down. Send to another.
    // 再次调用 handoff(worker)。有可能前面已经有一堆的待处理请求，因此检查下还有没有请求需要处理
    // 如有，已经空闲出来的worker可以接着处理请求
    this.handoff(worker);
  &#125;);
&#125;;
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2020-04-02T05:50:58.000Z" itemprop="datePublished">2020-04-02</time>
</div>
    
        <div class="article-category">
        <a class="article-category-link" href="/categories/Node-js/">Node.js</a>
        </div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-2020-03-深度玩转CSS-marker"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/article/2020/03/web%E5%89%8D%E7%AB%AF/2020-03-%E6%B7%B1%E5%BA%A6%E7%8E%A9%E8%BD%ACCSS-marker.html">你不知道的css ::marker用法</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <p>本文将介绍 CSS 中一个比较有意思的伪元素 <code>::marker</code>，利用它，我们可以让我们的文字序号变得更加的有意思！</p>
<h2 id="什么是-marker"><a href="#什么是-marker" class="headerlink" title="什么是 ::marker"></a>什么是 ::marker</h2><p>CSS 伪元素 <code>::marker</code> 是从 <a target="_blank" rel="noopener" href="https://drafts.csswg.org/css-lists-3/#marker-pseudo">CSS Pseudo-Elements Level 3</a> 开始新增，<a target="_blank" rel="noopener" href="https://drafts.csswg.org/css-pseudo-4/#marker-pseudo">CSS Pseudo-Elements Level 4</a> 中完善的一个比较新的伪元素，从 Chrome 86+ 开始得到浏览器的支持。</p>
<p>利用它，我们可以给元素添加一个伪元素，用于生成一个项目符号或者数字。</p>
        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2020-03-05T08:50:58.000Z" itemprop="datePublished">2020-03-05</time>
</div>
    
        <div class="article-category">
        <a class="article-category-link" href="/categories/web%E5%89%8D%E7%AB%AF/">web前端</a>
        </div>
    
    
        <div class="article-tag">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/css/" rel="tag">css</a></li></ul>
        </div>
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-2020-01-美化console-log的文本"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/article/2020/01/web%E5%89%8D%E7%AB%AF/2020-01-%E7%BE%8E%E5%8C%96console-log%E7%9A%84%E6%96%87%E6%9C%AC.html">美化console.log的文本</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="美化console-log的文本"><a href="#美化console-log的文本" class="headerlink" title="美化console.log的文本"></a>美化console.log的文本</h2><p>使用非常简单有意思：</p>
<pre><code>console.log(&quot;%c css88.com&quot;, &quot;font-size:20pt&quot;)
</code></pre>
<p>以%c开头，后面的文字就打印的信息，后面一个参数就是样式属性；</p>
<p>可以尝试多个样式，每碰到一个%c开头就会应用对应的样式：</p>
<pre><code>console.log(&quot;%c 前端开发 %c css88.com %c 愚人码头&quot;, &quot;color:red&quot;,&quot;&quot;,&quot;color:orange;font-weight:bold&quot;)
</code></pre>
        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2020-01-22T13:27:14.000Z" itemprop="datePublished">2020-01-22</time>
</div>
    
        <div class="article-category">
        <a class="article-category-link" href="/categories/web%E5%89%8D%E7%AB%AF/">web前端</a>
        </div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-2020-01-你所知道的background-position"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/article/2020/01/web%E5%89%8D%E7%AB%AF/2020-01-%E4%BD%A0%E6%89%80%E7%9F%A5%E9%81%93%E7%9A%84background-position.html">你所知道的background-position（转载）</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <p><code>background</code>属性是<a target="_blank" rel="noopener" href="https://www.w3.org/TR/css3-background/">CSS中最常见的属性之一</a>，它是一个简写属性，其包含<code>background-color</code>、<code>background-image</code>、<code>background-repeat</code>、<code>background-attachment</code>、<code>background-position</code>、<code>background-clip</code>、<code>background-origin</code>和<code>background-size</code>。你可能会说，这些属性再简单不过了，没有可讲的。这篇文章接下来要介绍的不是所有有关于<code>background</code>里面的属性，而是说说<code>background-position</code>属性。在详细介绍<code>background-position</code>之前，先要问大家，你真的了解这个属性吗？言外之意，接下来介绍是你所不了解的<code>background-position</code>相关细节。</p>
        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2020-01-20T12:17:43.000Z" itemprop="datePublished">2020-01-20</time>
</div>
    
        <div class="article-category">
        <a class="article-category-link" href="/categories/web%E5%89%8D%E7%AB%AF/">web前端</a>
        </div>
    
    
        <div class="article-tag">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/css/" rel="tag">css</a></li></ul>
        </div>
    
    </div>
</footer>

</article>

    
  

  
    <nav class="pagination">
        <a class="extend prev" rel="prev" href="/page/6/">Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/8/">Next</a>
    </nav>
  
</div>

                </section>
            </section>

            
            <aside class="sidebar sidebar-search-fix">
                

    <div class="search">
    <div class="has-icon-right">
        <input type="text" class="form-input" id="search" placeholder="SEARCH" autocomplete="off">
        <div class="form-icon">
            <box-icon name='search' color="#3c4859"></box-icon>
        </div>
    </div>
    <div class="search-result" id="search-ps"></div>
</div>


<div class="widget" id="widget">
    
      
    
      
  <div class="widget-wrap widget-cate">
    <div class="widget-title"><span>Categories</span></div>
    <div class="widget-inner">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Node-js/">Node.js</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Windows/">Windows</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/web%E5%89%8D%E7%AB%AF/">web前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%85%B6%E5%AE%83/">其它</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/">工具使用</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/">微信小程序</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%98%E8%85%BE%E6%89%8B%E6%9C%BA/">折腾手机</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%8E%A9%E8%BD%AC%E6%9C%8D%E5%8A%A1%E5%99%A8/">玩转服务器</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/">自动化测试</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap widget-tags">
    <div class="widget-title"><span>Tags</span></div>
    <div class="widget-inner">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AWSC/" rel="tag">AWSC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ajax/" rel="tag">Ajax</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-Stuido/" rel="tag">Android Stuido</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Apache/" rel="tag">Apache</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Django/" rel="tag">Django</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Esc/" rel="tag">Esc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/G-140W-CS/" rel="tag">G-140W-CS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML5/" rel="tag">HTML5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/" rel="tag">HTTP状态码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HUAWEI/" rel="tag">HUAWEI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Html/" rel="tag">Html</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ICP/" rel="tag">ICP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JSON/" rel="tag">JSON</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jquery/" rel="tag">Jquery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LAMP/" rel="tag">LAMP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lodash/" rel="tag">Lodash</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MD5/" rel="tag">MD5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MUI/" rel="tag">MUI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Manjaro/" rel="tag">Manjaro</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown/" rel="tag">Markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Matplotlib/" rel="tag">Matplotlib</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mysql/" rel="tag">Mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/" rel="tag">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PyInstaller/" rel="tag">PyInstaller</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Reg/" rel="tag">Reg</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SEM/" rel="tag">SEM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SEO/" rel="tag">SEO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SSL%E8%AF%81%E4%B9%A6/" rel="tag">SSL证书</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Selenium/" rel="tag">Selenium</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ubuntu/" rel="tag">Ubuntu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/" rel="tag">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue3/" rel="tag">Vue3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Webpack/" rel="tag">Webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows10/" rel="tag">Windows10</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/XHTML/" rel="tag">XHTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/YOLO/" rel="tag">YOLO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/apache/" rel="tag">apache</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/app%E4%B8%8A%E6%9E%B6/" rel="tag">app上架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bug/" rel="tag">bug</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cmd/" rel="tag">cmd</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/" rel="tag">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/darkflow/" rel="tag">darkflow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/express/" rel="tag">express</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/" rel="tag">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pacman/" rel="tag">pacman</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php/" rel="tag">php</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pip/" rel="tag">pip</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pm2/" rel="tag">pm2</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/socket-io/" rel="tag">socket.io</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/turtle/" rel="tag">turtle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/wechat/" rel="tag">wechat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/windows11/" rel="tag">windows11</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/wordcloud/" rel="tag">wordcloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B4%E6%9C%AB%E6%80%BB%E7%BB%93/" rel="tag">年末总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8A%93%E5%8C%85/" rel="tag">抓包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA/" rel="tag">虚拟主机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E8%91%97/" rel="tag">软著</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap widget-recent-posts">
    <div class="widget-title"><span>Recent Posts</span></div>
    <div class="widget-inner">
      <ul>
        
          <li>
            <a href="/article/2021/07/web%E5%89%8D%E7%AB%AF/2021-07-%E6%89%8B%E5%86%99mini-vue3%E7%B3%BB%E7%BB%9F.html">手写mini-Vue3系统,探究原理</a>
          </li>
        
          <li>
            <a href="/article/2021/07/Windows/2021-07-Window10%E5%A6%82%E4%BD%95%E5%8D%87%E7%BA%A7Window11%EF%BC%88%E4%BD%93%E9%AA%8C%E7%89%88%EF%BC%89%E8%AF%A6%E7%BB%86%E6%B5%81%E7%A8%8B.html">Window10升级Window11（体验版dev）详细流程</a>
          </li>
        
          <li>
            <a href="/article/2021/07/Windows/2021-07-%E5%AF%86%E9%92%A5%E5%8D%87%E7%BA%A7windows%E4%B8%93%E4%B8%9A%E7%89%88%E5%8D%87%E7%BA%A7%E5%AF%86%E9%92%A5%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98.html">密钥升级windows专业版，升级失败，之前密钥丢失问题</a>
          </li>
        
          <li>
            <a href="/article/2021/06/%E5%85%B6%E5%AE%83/2021-06-%E5%BA%94%E7%94%A8%E5%AE%9D%E4%B8%8A%E6%9E%B6%E6%8C%87%E5%8D%97.html">应用宝上架指南【详细教程】</a>
          </li>
        
          <li>
            <a href="/article/2021/03/%E5%85%B6%E5%AE%83/2021-03-%E9%98%BF%E9%87%8C%E4%BA%91%E7%94%B3%E8%AF%B7%E8%BD%AF%E4%BB%B6%E8%91%97%E4%BD%9C%E6%9D%83%E6%B5%81%E7%A8%8B.html">阿里云申请软件著作权流程</a>
          </li>
        
      </ul>
    </div>
  </div>

    
      
  <div class="widget-wrap widget-archive">
    <div class="widget-title"><span>Archive</span></div>
    <div class="widget-inner">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/">2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/">2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/">2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/">2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/">2015</a></li></ul>
    </div>
  </div>


    
</div>

<div id="backtop"><i class="icon icon-arrow-up"></i></div>
            </aside>
            
        </div>
    </div>

    <footer class="footer">
  <div class="footer-wave">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1440 320"><path fill="#3c4859" fill-opacity="1" d="M0,160L60,181.3C120,203,240,245,360,240C480,235,600,181,720,186.7C840,192,960,256,1080,261.3C1200,267,1320,213,1380,186.7L1440,160L1440,320L1380,320C1320,320,1200,320,1080,320C960,320,840,320,720,320C600,320,480,320,360,320C240,320,120,320,60,320L0,320Z"></path></svg>
  </div>

  <div class="footer-wrap">
    <div class="footer-inner">
      Oct1a &copy;
        2021<br> Powered By Hexo · Theme By <a href="https://github.com/lh1me/hexo-theme-aomori" target="_blank">Aomori</a>
          <br>
          <a target="_blank" rel="noopener" href="https://beian.miit.gov.cn" style="text-decoration:none"><img width="15" src="//img.alicdn.com/tfs/TB1..50QpXXXXX7XpXXXXXXXXXX-40-40.png"><span style="margin-left:8px">闽ICP备14018417号</span></a>
    </div>

  </div>

</footer>



    

        
<script src="/dist/build.js?1619416789282.js"></script>

          
<script src="/dist/custom.js?1619416789282.js"></script>


            

                

                    

</body>

</html>