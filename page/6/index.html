<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    
    <title>Oct1a</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    

    
        <meta property="algolia:search" data-application-id="8PAB37PRQA" data-api-key="6be1fd77c1546f943893acc1624e0fbe" data-index-name="blogs">
    

    

    

    

    

    
<link rel="stylesheet" href="/dist/build.css?v=1619416789282.css">


    <script>
        window.isPost = false
        window.aomori = {
            
            
            
        }
        window.aomori_logo_typed_animated = true
        window.aomori_search_algolia = true

    </script>

<meta name="generator" content="Hexo 5.4.0"></head>

<body>

    <div class="container">
    <header class="header">
        <div class="header-type">
            
            <div class="header-type-avatar avatar avatar-sm">
                <img src="/images/oct1a.jpg" alt="Oct1a_H">
            </div>
            
            <div class="header-type-inner">
                
                    <div id="typed-strings" style="display:none">
                        <p>Oct1a</p>
                    </div>
                    <a class="header-type-title" id="typed" href="/"></a>
                
    
                
            </div>
        </div>
        <div class="header-menu">
            <div class="header-menu-inner">
                
                <a href="/">Home</a>
                
                <a href="/archives">Archives</a>
                
                <a href="/photography">Photography</a>
                
            </div>
            <div class="header-menu-social">
                
    <a class="social" target="_blank" href="https://github.com/Oct1a">
        <box-icon type='logo' name='github'></box-icon>
    </a>

    <a class="social" target="_blank" href="https://www.jianshu.com/u/c9856b5ce227">
        <box-icon type='logo' name='firebase'></box-icon>
    </a>

            </div>
        </div>

        <div class="header-menu-mobile">
            <div class="header-menu-mobile-inner" id="mobile-menu-open">
                <i class="icon icon-menu"></i>
            </div>
        </div>
    </header>

    <div class="header-menu-mobile-menu">
        <div class="header-menu-mobile-menu-bg"></div>
        <div class="header-menu-mobile-menu-wrap">
            <div class="header-menu-mobile-menu-inner">
                <div class="header-menu-mobile-menu-close" id="mobile-menu-close">
                    <i class="icon icon-cross"></i>
                </div>
                <div class="header-menu-mobile-menu-list">
                    
                    <a href="/">Home</a>
                    
                    <a href="/archives">Archives</a>
                    
                    <a href="/photography">Photography</a>
                    
                </div>
            </div>
        </div>
    </div>

</div>

    <div class="container">
        <div class="main">
            <section class="inner">
                <section class="inner-main">
                    <div class="index">
  
    
      <article
id="post-2020-05-cookie"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/article/2020/04/Node-js/2020-05-cookie.html">Node.js-buffer</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="入门基础"><a href="#入门基础" class="headerlink" title="入门基础"></a>入门基础</h2><ul>
<li>domain：cookie属于哪个域，如果不显示声明，则限制只有当前域可以访问。比如当前域名为id.qq.com，那么默认当前域下的cookie <a target="_blank" rel="noopener" href="http://www.qq.com无法访问.如果某个cookie申明domain为qq.com,那么,只要是qq.com域下,都可以访问该cookie./">www.qq.com无法访问。如果某个cookie申明domain为qq.com，那么，只要是qq.com域下，都可以访问该cookie。</a></li>
<li>path：cookie所属的路径，比如声明path＝/，那么，所有路径下的页面都可以访问该cookie。如果声明cookie所属的path为/test，那么/test/sub-test/下的页面也可以访问该cookie，而/hello下的页面则无法访问该cookie。</li>
<li>httpOnly：页面的js无法读写该cookie。</li>
<li>secure：该cookie只能在https环境下使用。</li>
<li>expires：过期时间</li>
<li>maxAge：</li>
</ul>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2>
        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2020-04-02T05:50:58.000Z" itemprop="datePublished">2020-04-02</time>
</div>
    
        <div class="article-category">
        <a class="article-category-link" href="/categories/Node-js/">Node.js</a>
        </div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-2020-05-crypto-diffie-hellman"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/article/2020/04/Node-js/2020-05-crypto-diffie-hellman.html">Node.js-buffer</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Diffie-Hellman（简称DH）是密钥交换算法之一，它的作用是保证通信双方在非安全的信道中安全地交换密钥。目前DH最重要的应用场景之一，就是在HTTPS的握手阶段，客户端、服务端利用DH算法交换对称密钥。</p>
<p>下面会先简单介绍DH的数理基础，然后举例说明如何在nodejs中使用DH相关的API。</p>
<h2 id="数论基础"><a href="#数论基础" class="headerlink" title="数论基础"></a>数论基础</h2><p>要理解DH算法，需要掌握一定的数论基础。感兴趣的可以进一步研究推导过程，或者直接记住下面结论，然后进入下一节。</p>
<ol>
<li>假设 Y = a^X mod p，已知X的情况下，很容易算出Y；已知道Y的情况下，很难算出X；</li>
<li>(a^Xa mod p)^Xb mod p = a^(Xa * Xb) mod p</li>
</ol>
<h2 id="握手步骤说明"><a href="#握手步骤说明" class="headerlink" title="握手步骤说明"></a>握手步骤说明</h2><p>假设客户端、服务端挑选两个素数a、p（都公开），然后</p>
<ul>
<li>客户端：选择自然数Xa，Ya = a^Xa mod p，并将Ya发送给服务端；</li>
<li>服务端：选择自然数Xb，Yb = a^Xb mod p，并将Yb发送给客户端；</li>
<li>客户端：计算 Ka = Yb^Xa mod p</li>
<li>服务端：计算 Kb = Ya^Xb mod p</li>
</ul>
<blockquote>
<p>Ka = Yb^Xa mod p<br>    = (a^Xb mod p)^Xa mod p<br>    = a^(Xb * Xa) mod p<br>    = (a^Xa mod p)^Xb mod p<br>    = Ya^Xb mod p<br>    = Kb</p>
</blockquote>
<p>可以看到，尽管客户端、服务端彼此不知道对方的Xa、Xb，但算出了相等的secret。</p>
<h2 id="Nodejs代码示例"><a href="#Nodejs代码示例" class="headerlink" title="Nodejs代码示例"></a>Nodejs代码示例</h2><p>结合前面小结的介绍来看下面代码，其中，要点之一就是client、server采用相同的素数a、p。</p>
<pre><code class="javascript">var crypto = require(&#39;crypto&#39;);

var primeLength = 1024;  // 素数p的长度
var generator = 5;  // 素数a

// 创建客户端的DH实例
var client = crypto.createDiffieHellman(primeLength, generator);
// 产生公、私钥对，Ya = a^Xa mod p
var clientKey = client.generateKeys();

// 创建服务端的DH实例，采用跟客户端相同的素数a、p
var server = crypto.createDiffieHellman(client.getPrime(), client.getGenerator());
// 产生公、私钥对，Yb = a^Xb mod p
var serverKey = server.generateKeys();

// 计算 Ka = Yb^Xa mod p
var clientSecret = client.computeSecret(server.getPublicKey());
// 计算 Kb = Ya^Xb mod p
var serverSecret = server.computeSecret(client.getPublicKey());

// 由于素数p是动态生成的，所以每次打印都不一样
// 但是 clientSecret === serverSecret
console.log(clientSecret.toString(&#39;hex&#39;));
console.log(serverSecret.toString(&#39;hex&#39;));
</code></pre>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a target="_blank" rel="noopener" href="http://wsfdl.com/algorithm/2016/02/04/%E7%90%86%E8%A7%A3Diffie-Hellman%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E7%AE%97%E6%B3%95.html">理解 Deffie-Hellman 密钥交换算法</a></p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-cn/%E8%BF%AA%E8%8F%B2-%E8%B5%AB%E7%88%BE%E6%9B%BC%E5%AF%86%E9%91%B0%E4%BA%A4%E6%8F%9B">迪菲-赫尔曼密钥交换</a></p>
<p><a target="_blank" rel="noopener" href="https://cafedev.org/article/2016/11/secure-messages-in-nodejs-using-ecdh/">Secure messages in NodeJSusing ECDH</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/">Keyless SSL: The Nitty Gritty Technical Details</a></p>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2020-04-02T05:50:58.000Z" itemprop="datePublished">2020-04-02</time>
</div>
    
        <div class="article-category">
        <a class="article-category-link" href="/categories/Node-js/">Node.js</a>
        </div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-2020-05-crypto-theory"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/article/2020/04/Node-js/2020-05-crypto-theory.html">Node.js-buffer</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h1 id="Nodejs进阶：crypto模块之理论篇"><a href="#Nodejs进阶：crypto模块之理论篇" class="headerlink" title="Nodejs进阶：crypto模块之理论篇"></a>Nodejs进阶：crypto模块之理论篇</h1><h2 id="一、-文章概述"><a href="#一、-文章概述" class="headerlink" title="一、 文章概述"></a>一、 文章概述</h2><p>互联网时代，网络上的数据量每天都在以惊人的速度增长。同时，各类网络安全问题层出不穷。在信息安全重要性日益凸显的今天，作为一名开发者，需要加强对安全的认识，并通过技术手段增强服务的安全性。</p>
<p><code>crypto</code>模块是nodejs的核心模块之一，它提供了安全相关的功能，如摘要运算、加密、电子签名等。很多初学者对着长长的API列表，不知如何上手，因此它背后涉及了大量安全领域的知识。</p>
<p>本文重点讲解API背后的理论知识，主要包括如下内容：</p>
<ol>
<li>摘要（hash）、基于摘要的消息验证码（HMAC）</li>
<li>对称加密、非对称加密、电子签名</li>
<li>分组加密模式</li>
</ol>
<h2 id="二、摘要（hash）"><a href="#二、摘要（hash）" class="headerlink" title="二、摘要（hash）"></a>二、摘要（hash）</h2><p>摘要（digest）：将长度不固定的消息作为输入，通过运行hash函数，生成固定长度的输出，这段输出就叫做摘要。通常用来验证消息完整、未被篡改。</p>
<p>摘要运算是不可逆的。也就是说，输入固定的情况下，产生固定的输出。但知道输出的情况下，无法反推出输入。</p>
<p>伪代码如下。</p>
<blockquote>
<p>digest = Hash(message)</p>
</blockquote>
<p>常见的摘要算法 与 对应的输出位数如下：</p>
<ul>
<li>MD5：128位</li>
<li>SHA-1：160位</li>
<li>SHA256 ：256位</li>
<li>SHA512：512位</li>
</ul>
<p>nodejs中的例子：</p>
<pre><code class="javascript">var crypto = require(&#39;crypto&#39;);
var md5 = crypto.createHash(&#39;md5&#39;);

var message = &#39;hello&#39;;
var digest = md5.update(message, &#39;utf8&#39;).digest(&#39;hex&#39;);

console.log(digest);
// 输出如下：注意这里是16进制
// 5d41402abc4b2a76b9719d911017c592
</code></pre>
<blockquote>
<p>备注：在各类文章或文献中，摘要、hash、散列 这几个词经常会混用，导致不少初学者看了一脸懵逼，其实大部分时候指的都是一回事，记住上面对摘要的定义就好了。</p>
</blockquote>
<h2 id="三、MAC、HMAC"><a href="#三、MAC、HMAC" class="headerlink" title="三、MAC、HMAC"></a>三、MAC、HMAC</h2><p>MAC（Message Authentication Code）：消息认证码，用以保证数据的完整性。运算结果取决于消息本身、秘钥。</p>
<p>MAC可以有多种不同的实现方式，比如HMAC。</p>
<p>HMAC（Hash-based Message Authentication Code）：可以粗略地理解为带秘钥的hash函数。</p>
<p>nodejs例子如下：</p>
<pre><code class="javascript">const crypto = require(&#39;crypto&#39;);

// 参数一：摘要函数
// 参数二：秘钥
let hmac = crypto.createHmac(&#39;md5&#39;, &#39;123456&#39;);
let ret = hmac.update(&#39;hello&#39;).digest(&#39;hex&#39;);

console.log(ret);
// 9c699d7af73a49247a239cb0dd2f8139
</code></pre>
<h2 id="四、对称加密、非对称加密"><a href="#四、对称加密、非对称加密" class="headerlink" title="四、对称加密、非对称加密"></a>四、对称加密、非对称加密</h2><p><strong>加密/解密</strong>：给定明文，通过一定的算法，产生加密后的密文，这个过程叫加密。反过来就是解密。</p>
<blockquote>
<p>encryptedText = encrypt( plainText )<br>plainText = decrypt( encryptedText )</p>
</blockquote>
<p><strong>秘钥</strong>：为了进一步增强加/解密算法的安全性，在加/解密的过程中引入了秘钥。秘钥可以视为加/解密算法的参数，在已知密文的情况下，如果不知道解密所用的秘钥，则无法将密文解开。</p>
<blockquote>
<p>encryptedText = encrypt(plainText, encryptKey)<br>plainText = decrypt(encryptedText, decryptKey)</p>
</blockquote>
<p>根据加密、解密所用的秘钥是否相同，可以将加密算法分为<strong>对称加密</strong>、<strong>非对称加密</strong>。</p>
<h3 id="1、对称加密"><a href="#1、对称加密" class="headerlink" title="1、对称加密"></a>1、对称加密</h3><p>加密、解密所用的秘钥是相同的，即<code>encryptKey === decryptKey</code>。</p>
<p>常见的对称加密算法：DES、3DES、AES、Blowfish、RC5、IDEA。</p>
<p>加、解密伪代码：</p>
<blockquote>
<p>encryptedText = encrypt(plainText, key); // 加密<br>plainText = decrypt(encryptedText, key); // 解密</p>
</blockquote>
<h3 id="2、非对称加密"><a href="#2、非对称加密" class="headerlink" title="2、非对称加密"></a>2、非对称加密</h3><p>又称公开秘钥加密。加密、解密所用的秘钥是不同的，即<code>encryptKey !== decryptKey</code>。</p>
<p>加密秘钥公开，称为公钥。解密秘钥保密，称为秘钥。</p>
<p>常见的非对称加密算法：RSA、DSA、ElGamal。</p>
<p>加、解密伪代码：</p>
<blockquote>
<p>encryptedText = encrypt(plainText, publicKey); // 加密<br>plainText = decrypt(encryptedText, priviteKey); // 解密</p>
</blockquote>
<h3 id="3、对比与应用"><a href="#3、对比与应用" class="headerlink" title="3、对比与应用"></a>3、对比与应用</h3><p>除了秘钥的差异，还有运算速度上的差异。通常来说：</p>
<ol>
<li>对称加密速度要快于非对称加密。</li>
<li>非对称加密通常用于加密短文本，对称加密通常用于加密长文本。</li>
</ol>
<p>两者可以结合起来使用，比如HTTPS协议，可以在握手阶段，通过RSA来交换生成对称秘钥。在之后的通讯阶段，可以使用对称加密算法对数据进行加密，秘钥则是握手阶段生成的。</p>
<blockquote>
<p>备注：对称秘钥交换不一定通过RSA，还可以通过类似DH来完成，这里不展开。</p>
</blockquote>
<h2 id="五、数字签名"><a href="#五、数字签名" class="headerlink" title="五、数字签名"></a>五、数字签名</h2><p>从<strong>签名</strong>大致可以猜到<strong>数字签名</strong>的用途。主要作用如下：</p>
<ol>
<li>确认信息来源于特定的主体。</li>
<li>确认信息完整、未被篡改。</li>
</ol>
<p>为了达到上述目的，需要有两个过程：</p>
<ol>
<li>发送方：生成签名。</li>
<li>接收方：验证签名。</li>
</ol>
<h3 id="1、发送方生成签名"><a href="#1、发送方生成签名" class="headerlink" title="1、发送方生成签名"></a>1、发送方生成签名</h3><ol>
<li>计算原始信息的摘要。</li>
<li>通过私钥对摘要进行签名，得到电子签名。</li>
<li>将原始信息、电子签名，发送给接收方。</li>
</ol>
<p>附：签名伪代码</p>
<blockquote>
<p>digest = hash(message); // 计算摘要<br>digitalSignature = sign(digest,  priviteKey); // 计算数字签名</p>
</blockquote>
<h3 id="2、接收方验证签名"><a href="#2、接收方验证签名" class="headerlink" title="2、接收方验证签名"></a>2、接收方验证签名</h3><ol>
<li>通过公钥解开电子签名，得到摘要D1。（如果解不开，信息来源主体校验失败）</li>
<li>计算原始信息的摘要D2。</li>
<li>对比D1、D2，如果D1等于D2，说明原始信息完整、未被篡改。</li>
</ol>
<p>附：签名验证伪代码</p>
<blockquote>
<p>digest1 = verify(digitalSignature, publicKey); // 获取摘要<br>digest2 = hash(message); // 计算原始信息的摘要<br>digest1 === digest2 // 验证是否相等</p>
</blockquote>
<h3 id="3、对比非对称加密"><a href="#3、对比非对称加密" class="headerlink" title="3、对比非对称加密"></a>3、对比非对称加密</h3><p>由于RSA算法的特殊性，加密/解密、签名/验证 看上去特别像，很多同学都很容易混淆。先记住下面结论，后面有时间再详细介绍。</p>
<ol>
<li>加密/解密：公钥加密，私钥解密。</li>
<li>签名/验证：私钥签名，公钥验证。</li>
</ol>
<h2 id="六、分组加密模式、填充、初始化向量"><a href="#六、分组加密模式、填充、初始化向量" class="headerlink" title="六、分组加密模式、填充、初始化向量"></a>六、分组加密模式、填充、初始化向量</h2><p>常见的对称加密算法，如AES、DES都采用了分组加密模式。这其中，有三个关键的概念需要掌握：模式、填充、初始化向量。</p>
<p>搞清楚这三点，才会知道crypto模块对称加密API的参数代表什么含义，出了错知道如何去排查。</p>
<h3 id="1、分组加密模式"><a href="#1、分组加密模式" class="headerlink" title="1、分组加密模式"></a>1、分组加密模式</h3><p>所谓的分组加密，就是将（较长的）明文拆分成固定长度的块，然后对拆分的块按照特定的模式进行加密。</p>
<p>常见的分组加密模式有：ECB（不安全）、CBC（最常用）、CFB、OFB、CTR等。</p>
<p>以最简单的ECB为例，先将消息拆分成等分的模块，然后利用秘钥进行加密。</p>
<p><img src="./1514888679104.png" alt="Alt text"></p>
<p>图片来源：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Electronic_Codebook_%28ECB%29">这里</a>，更多关于分组加密模式的介绍可以参考 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Common_modes">wiki</a>。</p>
<blockquote>
<p>后面假设每个块的长度为128位</p>
</blockquote>
<h3 id="2、初始化向量：IV"><a href="#2、初始化向量：IV" class="headerlink" title="2、初始化向量：IV"></a>2、初始化向量：IV</h3><p>为了增强算法的安全性，部分分组加密模式（CFB、OFB、CTR）中引入了初始化向量（IV），使得加密的结果随机化。也就是说，对于同一段明文，IV不同，加密的结果不同。</p>
<p>以CBC为例，每一个数据块，都与前一个加密块进行亦或运算后，再进行加密。对于第一个数据块，则是与IV进行亦或。</p>
<p>IV的大小跟数据块的大小有关（128位），跟秘钥的长度无关。</p>
<p>如图所示，图片来源 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_Block_Chaining_%28CBC%29">这里</a></p>
<p><img src="./1514892463299.png" alt="Alt text"></p>
<h3 id="3、填充：padding"><a href="#3、填充：padding" class="headerlink" title="3、填充：padding"></a>3、填充：padding</h3><p>分组加密模式需要对长度固定的块进行加密。分组拆分完后，最后一个数据块长度可能小于128位，此时需要进行填充以满足长度要求。</p>
<p>填充方式有多重。常见的填充方式有<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc5652#section-6.3">PKCS7</a>。</p>
<p>假设分组长度为k字节，最后一个分组长度为k-last，可以看到：</p>
<ol>
<li>不管明文长度是多少，加密之前都会会对明文进行填充 （不然解密函数无法区分最后一个分组是否被填充了，因为存在最后一个分组长度刚好等于k的情况）</li>
<li>如果最后一个分组长度等于k-last === k，那么填充内容为一个完整的分组 k k k … k （k个字节）</li>
<li>如果最后一个分组长度小于k-last &lt; k，那么填充内容为 k-last mod k</li>
</ol>
<pre><code>                     01 -- if lth mod k = k-1
                  02 02 -- if lth mod k = k-2
                      .
                      .
                      .
            k k ... k k -- if lth mod k = 0
</code></pre>
<h3 id="概括来说"><a href="#概括来说" class="headerlink" title="概括来说"></a>概括来说</h3><ol>
<li>分组加密：先将明文切分成固定长度的块（128位），再进行加密。</li>
<li>分组加密的几种模式：ECB（不安全）、CBC（最常用）、CFB、OFB、CTR。</li>
<li>填充(padding)：部分加密模式，当最后一个块的长度小于128位时，需要通过特定的方式进行填充。（ECB、CBC需要填充，CFB、OFB、CTR不需要填充）</li>
<li>初始化向量（IV）：部分加密模式（CFB、OFB、CTR）会将 明文块 与 前一个密文块进行亦或操作。对于第一个明文块，不存在前一个密文块，因此需要提供初始化向量IV（把IV当做第一个明文块 之前的 密文块）。此外，IV也可以让加密结果随机化。</li>
</ol>
<h2 id="七、写在后面"><a href="#七、写在后面" class="headerlink" title="七、写在后面"></a>七、写在后面</h2><p>crypto模块涉及的安全知识较多，篇幅所限，这里没办法一一展开。为了讲解方便，部分内容可能不够严谨，如有错漏敬请指出。</p>
<h2 id="八、相关链接"><a href="#八、相关链接" class="headerlink" title="八、相关链接"></a>八、相关链接</h2><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Cryptographic_hash_function">Cryptographic hash function</a></p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Hash-based_message_authentication_code">Hash-based message authentication code</a></p>
<p><a target="_blank" rel="noopener" href="https://crypto.stackexchange.com/questions/2936/hmac-vs-mac-functions">HMAC vs MAC functions</a></p>
<p><a target="_blank" rel="noopener" href="https://crypto.stackexchange.com/questions/6523/what-is-the-difference-between-mac-and-hmac">What is the difference between MAC and HMAC?</a></p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation">Block cipher mode of operation</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/25912483/answer/31653639">RSA的公钥和私钥到底哪个才是用来加密和哪个用来解密？ - 刘巍然-学酥的回答 - 知乎</a></p>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2020-04-02T05:50:58.000Z" itemprop="datePublished">2020-04-02</time>
</div>
    
        <div class="article-category">
        <a class="article-category-link" href="/categories/Node-js/">Node.js</a>
        </div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-2020-05-debugLog"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/article/2020/04/Node-js/2020-05-debugLog.html">Node.js-buffer</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在node程序开发中时，经常需要打印调试日志。用的比较多的是debug模块，下文简单举几个例子进行说明。</p>
<blockquote>
<p>备注：node在0.11.3版本也加入了util.debuglog()用于打印调试日志，使用方法跟debug模块大同小异。</p>
</blockquote>
<h2 id="基础例子"><a href="#基础例子" class="headerlink" title="基础例子"></a>基础例子</h2><p>使用很简单，运行node程序时，加上<code>DEBUG=Aapp</code>环境变量即可。</p>
<pre><code class="javascript">/**
 * debug基础例子
 */
var debug = require(&#39;debug&#39;)(&#39;app&#39;);

// 运行 DEBUG=app node 01.js
// 输出：app hello +0ms
debug(&#39;hello&#39;);
</code></pre>
<h2 id="例子：命名空间"><a href="#例子：命名空间" class="headerlink" title="例子：命名空间"></a>例子：命名空间</h2><p>当项目程序变得复杂，我们需要对日志进行分类打印，debug支持命令空间，如下所示。</p>
<ul>
<li><code>DEBUG=app,api</code>：表示同时打印出命名空间为app、api的调试日志。</li>
<li><code>DEBUG=a*</code>：支持通配符，所有命名空间为a开头的调试日志都打印出来。</li>
</ul>
<pre><code class="javascript">/**
 * debug例子：命名空间
 */
var debug = require(&#39;debug&#39;);
var appDebug = debug(&#39;app&#39;);
var apiDebug = debug(&#39;api&#39;);

// 分别运行下面几行命令看下效果
//
//     DEBUG=app node 02.js
//     DEBUG=api node 02.js
//     DEBUG=app,api node 02.js
//     DEBUG=a* node 02.js
//
appDebug(&#39;hello&#39;);
apiDebug(&#39;hello&#39;);
</code></pre>
<h2 id="例子：命名空间排除"><a href="#例子：命名空间排除" class="headerlink" title="例子：命名空间排除"></a>例子：命名空间排除</h2><p>有的时候，我们想要打印出所有的调试日志，除了个别命名空间下的。这个时候，可以通过<code>-</code>来进行排除，如下所示。<code>-account*</code>表示排除所有以account开头的命名空间的调试日志。</p>
<pre><code class="javascript">/**
 * debug例子：排查命名空间
 */
var debug = require(&#39;debug&#39;);
var listDebug = debug(&#39;app:list&#39;);
var profileDebug = debug(&#39;app:profile&#39;);
var loginDebug = debug(&#39;account:login&#39;);

// 分别运行下面几行命令看下效果
//
//     DEBUG=* node 03.js
//     DEBUG=*,-account* node 03.js
//
listDebug(&#39;hello&#39;);
profileDebug(&#39;hello&#39;);
loginDebug(&#39;hello&#39;);
</code></pre>
<h2 id="例子：自定义格式化"><a href="#例子：自定义格式化" class="headerlink" title="例子：自定义格式化"></a>例子：自定义格式化</h2><p>debug也支持格式化输出，如下例子所示。</p>
<pre><code class="javascript">var debug = require(&#39;debug&#39;)(&#39;app&#39;);

debug(&#39;my name is %s&#39;, &#39;chyingp&#39;);
</code></pre>
<p>此外，也可以自定义格式化内容。</p>
<pre><code class="javascript">/**
 * debug：自定义格式化
 */
var createDebug = require(&#39;debug&#39;)

createDebug.formatters.h = function(v) &#123;
  return v.toUpperCase();
&#125;;

var debug = createDebug(&#39;foo&#39;);

// 运行 DEBUG=foo node 04.js
// 输出 foo My name is CHYINGP +0ms
debug(&#39;My name is %h&#39;, &#39;chying&#39;);
</code></pre>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p>debug：<a target="_blank" rel="noopener" href="https://github.com/visionmedia/debug">https://github.com/visionmedia/debug</a><br>debuglog：<a target="_blank" rel="noopener" href="https://nodejs.org/api/util.html#util_util_debuglog_section">https://nodejs.org/api/util.html#util_util_debuglog_section</a></p>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2020-04-02T05:50:58.000Z" itemprop="datePublished">2020-04-02</time>
</div>
    
        <div class="article-category">
        <a class="article-category-link" href="/categories/Node-js/">Node.js</a>
        </div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-2020-05-debug-log"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/article/2020/04/Node-js/2020-05-debug-log.html">Node.js-buffer</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在node程序开发中时，经常需要打印调试日志。用的比较多的是debug模块，比如express框架中就用到了。下文简单举几个例子进行说明。</p>
<blockquote>
<p>备注：node在0.11.3版本也加入了util.debuglog()用于打印调试日志，使用方法跟debug模块大同小异。</p>
</blockquote>
<h2 id="基础例子"><a href="#基础例子" class="headerlink" title="基础例子"></a>基础例子</h2><p>首先，安装<code>debug</code>模块。</p>
<pre><code class="bash">npm install debug
</code></pre>
<p>使用很简单，运行node程序时，加上<code>DEBUG=app</code>环境变量即可。</p>
<pre><code class="javascript">/**
 * debug基础例子
 */
var debug = require(&#39;debug&#39;)(&#39;app&#39;);

// 运行 DEBUG=app node 01.js
// 输出：app hello +0ms
debug(&#39;hello&#39;);
</code></pre>
<h2 id="例子：命名空间"><a href="#例子：命名空间" class="headerlink" title="例子：命名空间"></a>例子：命名空间</h2><p>当项目程序变得复杂，我们需要对日志进行分类打印，debug支持命令空间，如下所示。</p>
<ul>
<li><code>DEBUG=app,api</code>：表示同时打印出命名空间为app、api的调试日志。</li>
<li><code>DEBUG=a*</code>：支持通配符，所有命名空间为a开头的调试日志都打印出来。</li>
</ul>
<pre><code class="javascript">/**
 * debug例子：命名空间
 */
var debug = require(&#39;debug&#39;);
var appDebug = debug(&#39;app&#39;);
var apiDebug = debug(&#39;api&#39;);

// 分别运行下面几行命令看下效果
//
//     DEBUG=app node 02.js
//     DEBUG=api node 02.js
//     DEBUG=app,api node 02.js
//     DEBUG=a* node 02.js
//
appDebug(&#39;hello&#39;);
apiDebug(&#39;hello&#39;);
</code></pre>
<h2 id="例子：命名空间排除"><a href="#例子：命名空间排除" class="headerlink" title="例子：命名空间排除"></a>例子：命名空间排除</h2><p>有的时候，我们想要打印出所有的调试日志，除了个别命名空间下的。这个时候，可以通过<code>-</code>来进行排除，如下所示。<code>-account*</code>表示排除所有以account开头的命名空间的调试日志。</p>
<pre><code class="javascript">/**
 * debug例子：排查命名空间
 */
var debug = require(&#39;debug&#39;);
var listDebug = debug(&#39;app:list&#39;);
var profileDebug = debug(&#39;app:profile&#39;);
var loginDebug = debug(&#39;account:login&#39;);

// 分别运行下面几行命令看下效果
//
//     DEBUG=* node 03.js
//     DEBUG=*,-account* node 03.js
//
listDebug(&#39;hello&#39;);
profileDebug(&#39;hello&#39;);
loginDebug(&#39;hello&#39;);
</code></pre>
<h2 id="例子：自定义格式化"><a href="#例子：自定义格式化" class="headerlink" title="例子：自定义格式化"></a>例子：自定义格式化</h2><p>debug也支持格式化输出，如下例子所示。</p>
<pre><code class="javascript">var debug = require(&#39;debug&#39;)(&#39;app&#39;);

debug(&#39;my name is %s&#39;, &#39;chyingp&#39;);
</code></pre>
<p>此外，也可以自定义格式化内容。</p>
<pre><code class="javascript">/**
 * debug：自定义格式化
 */
var createDebug = require(&#39;debug&#39;)

createDebug.formatters.h = function(v) &#123;
  return v.toUpperCase();
&#125;;

var debug = createDebug(&#39;foo&#39;);

// 运行 DEBUG=foo node 04.js
// 输出 foo My name is CHYINGP +0ms
debug(&#39;My name is %h&#39;, &#39;chying&#39;);
</code></pre>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p>debug：<a target="_blank" rel="noopener" href="https://github.com/visionmedia/debug">https://github.com/visionmedia/debug</a><br>debuglog：<a target="_blank" rel="noopener" href="https://nodejs.org/api/util.html#util_util_debuglog_section">https://nodejs.org/api/util.html#util_util_debuglog_section</a></p>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2020-04-02T05:50:58.000Z" itemprop="datePublished">2020-04-02</time>
</div>
    
        <div class="article-category">
        <a class="article-category-link" href="/categories/Node-js/">Node.js</a>
        </div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-2020-05-express-session-deep-in"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/article/2020/04/Node-js/2020-05-express-session-deep-in.html">Node.js-buffer</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本文先简单介绍session跟cookie的区别与联系，接着深入剖析<code>express-session</code>中间件的实现。关于<code>express-session</code>的基础使用，可参见笔者前面的文章。</p>
<h2 id="session-vs-cookie-vs-登录态"><a href="#session-vs-cookie-vs-登录态" class="headerlink" title="session vs cookie vs 登录态"></a>session vs cookie vs 登录态</h2><p>HTTP是无状态的，也就是说，同个用户，多次访问同一个网站，网站无法区分前后访问的是否同个用户。cookie跟session的出现很好的解决了这个问题。</p>
<p>抛开两者的学术定义，从应用的角度来讲，session跟cookie就是一对好基友，可以用来实现用户的身份识别。</p>
<p>session是保存在服务端的小段数据，cookie是保存在用户本地的小段数据，它们一般是一一对应的。</p>
<p>上面的解释比较抽象，先举两个常见的例子：<strong>用户登录</strong> 和 <strong>登录态检验</strong>。</p>
<h3 id="用户登录"><a href="#用户登录" class="headerlink" title="用户登录"></a>用户登录</h3><ol>
<li>张三：在网站输入用户名(zhang)、密码，点击“登录”。</li>
<li>浏览器：向服务端发送登录请求。</li>
<li>服务端：收到登录请求，对 用户名、密码 进行校验，且校验通过。</li>
<li>服务端：把张三的用户名 zhang 写到本地文件 session.txt。（session）</li>
<li>服务端：请求成功返回，附带 <code>Set-Cookie:uid=zhang</code> 首部。</li>
<li>浏览器：收到服务端返回，检测到 <code>Set-Cookie</code> 首部，将cookie(<code>uid=zhang</code>)保存到本地。(cookie)</li>
</ol>
<h3 id="登录态检验"><a href="#登录态检验" class="headerlink" title="登录态检验"></a>登录态检验</h3><p>张三再次访问网站：</p>
<ol>
<li>张三：访问网站的个人主页。</li>
<li>浏览器：向服务端发送访问请求（带上之前的cookie）。</li>
<li>服务端：解析cookie，找到<code>uid=zhang</code>。</li>
<li>服务端：查找本地session.txt，发现<code>uid=zhang</code>这条记录，判断用户已登录。</li>
<li>服务端：返回个人主页。</li>
</ol>
<h2 id="express-session实现原理"><a href="#express-session实现原理" class="headerlink" title="express-session实现原理"></a>express-session实现原理</h2><p>关键配置如下。其中，<code>saveUninitialized</code>若为<code>true</code>，对状态为“未初始化”的会话，服务端会自动为该会话创建session id，并保存到本地。</p>
<p>对于需要实现登录功能的站点，需要将<code>saveUninitialized</code>设置为<code>false</code>。</p>
<pre><code class="js">app.use(session(&#123;
    name: identityKey,
    secret: &#39;chyingp&#39;,  // 用来对session id相关的cookie进行签名
    store: new FileStore(),  // 本地存储session（文本文件，也可以选择其他store，比如redis的）
    saveUninitialized: false,  // 是否自动保存未初始化的会话，建议false
    resave: false,  // 是否每次都重新保存会话，建议false
    cookie: &#123;
        maxAge: 10 * 1000  // 有效期，单位是毫秒
    &#125;
&#125;));
</code></pre>
<p>从请求的生命周期来看下express-session是怎么发挥作用的。</p>
<p>首先，是一个“未初始化”的请求（比如第一次访问网站的用户）</p>
<pre><code class="js">app.use(session(/* 配置项 */));
app.use(&#39;/&#39;, function(req, res, next)&#123;
    res.end(&#39;ok&#39;);
&#125;);
</code></pre>
<h2 id="跟cookie-parser的关联"><a href="#跟cookie-parser的关联" class="headerlink" title="跟cookie-parser的关联"></a>跟cookie-parser的关联</h2><h2 id="关注点"><a href="#关注点" class="headerlink" title="关注点"></a>关注点</h2><ol>
<li>防止cookie篡改</li>
<li>登录态超时机制</li>
<li>登录态主动失效机制</li>
</ol>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2020-04-02T05:50:58.000Z" itemprop="datePublished">2020-04-02</time>
</div>
    
        <div class="article-category">
        <a class="article-category-link" href="/categories/Node-js/">Node.js</a>
        </div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-2020-05-express-session实现简易身份认证"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/article/2020/04/Node-js/2020-05-express-session%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81.html">Node.js-buffer</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="文档概览"><a href="#文档概览" class="headerlink" title="文档概览"></a>文档概览</h2><p>本文基于express、express-session实现了简易的登录/登出功能。</p>
        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2020-04-02T05:50:58.000Z" itemprop="datePublished">2020-04-02</time>
</div>
    
        <div class="article-category">
        <a class="article-category-link" href="/categories/Node-js/">Node.js</a>
        </div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-2020-05-https"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/article/2020/04/Node-js/2020-05-https.html">Node.js-buffer</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="客户端例子：不受信任的证书"><a href="#客户端例子：不受信任的证书" class="headerlink" title="客户端例子：不受信任的证书"></a>客户端例子：不受信任的证书</h2><p>我们知道，有些网站的HTTPS证书会被浏览器标识为不受信任，有可能是以下情况导致的：</p>
<ul>
<li>颁发证书的机构不在操作系统的受信列表里</li>
<li>办法证书的机构在操作系统的受信列表里，但证书的安全级别不够</li>
</ul>
<p>比如我们访问<a target="_blank" rel="noopener" href="https://kyfw.12306.cn/otn/regist/init">12306</a>，chrome就会提示你“您的连接不是私密连接，攻击者可能会试图从kyfw.12306.cn窃取您的信息”。</p>
<p>那么，当我们用node向12306发起请求时，又会是什么状况呢？下面就来试下</p>
<pre><code class="js">var https = require(&#39;https&#39;);

https.get(&#39;https://www.baidu.com&#39;, function(res)&#123;
    res.on(&#39;data&#39;, function(data)&#123;
        process.stdout.write(data);
    &#125;);
&#125;).on(&#39;error&#39;, function(err)&#123;
    console.error(err);
&#125;);
</code></pre>
<p>运行上面代码，输出如下。可以看到出现报错，提示信息是“self signed certificate in certificate chain”。大意就是说证书是网站自己签发的，不安全。</p>
<pre><code class="bash">&#123; Error: self signed certificate in certificate chain
    at Error (native)
    at TLSSocket.&lt;anonymous&gt; (_tls_wrap.js:1055:38)
    at emitNone (events.js:86:13)
    at TLSSocket.emit (events.js:185:7)
    at TLSSocket._finishInit (_tls_wrap.js:580:8)
    at TLSWrap.ssl.onhandshakedone (_tls_wrap.js:412:38) code: &#39;SELF_SIGNED_CERT_IN_CHAIN&#39; &#125;
</code></pre>
<p>出现上述错误怎么处理呢？我们知道，如果是在浏览器里访问，有两种处理方式：</p>
<ul>
<li>忽略浏览器的安全提示，继续访问（浏览器可能会直接禁止你访问）</li>
<li>将网站的根证书导入到操作系统的受信任根证书列表里</li>
</ul>
<h2 id="入门示例"><a href="#入门示例" class="headerlink" title="入门示例"></a>入门示例</h2><p>TODO</p>
<h2 id="基础讲解"><a href="#基础讲解" class="headerlink" title="基础讲解"></a>基础讲解</h2><p>。。。</p>
<h2 id="本地证书"><a href="#本地证书" class="headerlink" title="本地证书"></a>本地证书</h2><p>。。。</p>
<h2 id="服务器：自签名证书"><a href="#服务器：自签名证书" class="headerlink" title="服务器：自签名证书"></a>服务器：自签名证书</h2><pre><code class="bash">➜  server git:(master) ✗ mkdir cert
➜  server git:(master) ✗ cd cert
➜  cert git:(master) ✗ openssl genrsa -out chyingp-key.pem 2048
Generating RSA private key, 2048 bit long modulus
.............................+++
..........................................+++
e is 65537 (0x10001)
➜  cert git:(master) ✗ openssl req -new -sha256 -key chyingp-key.pem -out chyingp-csr.pem
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter &#39;.&#39;, the field will be left blank.
-----
Country Name (2 letter code) [AU]:CN
State or Province Name (full name) [Some-State]:Guangdong
Locality Name (eg, city) []:Shenzhen
Organization Name (eg, company) [Internet Widgits Pty Ltd]:YH
Organizational Unit Name (eg, section) []:web
Common Name (e.g. server FQDN or YOUR name) []:www.chyingp.com
Email Address []:416394284@qq.com

Please enter the following &#39;extra&#39; attributes
to be sent with your certificate request
A challenge password []:123456
An optional company name []:YH
➜  cert git:(master) ✗ openssl x509 -req -in chyingp-csr.pem -signkey chyingp-key.pem -out chyingp-cert.pem
</code></pre>
<h2 id="私有CA签名的证书"><a href="#私有CA签名的证书" class="headerlink" title="私有CA签名的证书"></a>私有CA签名的证书</h2><p>首先，创建自签名的CA证书</p>
<pre><code class="bash"># 创建ca的私钥
openssl genrsa -out my-ca.key.pem 2048

# 创建ca的证书
openssl req \
  -x509 \
  -new \
  -nodes \
  -key my-ca.key.pem \
  -days 1024 \
  -out my-ca.crt.pem \
  -subj &quot;/C=CN/ST=Guandong/L=Shenzhen/O=YH Inc/CN=chyingp.com&quot;
</code></pre>
<p>然后，创建用CA的私钥进行签名的网站证书</p>
<pre><code class="bash"># 创建私钥
openssl genrsa \
  -out my-server.key.pem \
  2048

# 创建证书签名请求
openssl req -new \
  -key my-server.key.pem \
  -out my-server.csr.pem \
  -subj &quot;/C=CN/ST=Guandong/L=Shenzhen/O=YH Inc/CN=www.chyingp.com&quot;

# 创建网站证书
openssl x509 \
  -req -in my-server.csr.pem \
  -CA my-ca.crt.pem \
  -CAkey my-ca.key.pem \
  -CAcreateserial \
  -out my-server.crt.pem \
  -days 500
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2020-04-02T05:50:58.000Z" itemprop="datePublished">2020-04-02</time>
</div>
    
        <div class="article-category">
        <a class="article-category-link" href="/categories/Node-js/">Node.js</a>
        </div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-2020-05-log4js"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/article/2020/04/Node-js/2020-05-log4js.html">Node.js-buffer</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <p>对于线上项目用来说，日志是非常重要的一环。log4js是使用得比较多的一个日志组件，经常跟Express一起配合使用。本文从入门实例开始，讲解log4js的使用，以及如何跟Express进行整合。</p>
<h2 id="入门例子"><a href="#入门例子" class="headerlink" title="入门例子"></a>入门例子</h2><p>输出日志如下，包括日志打印时间、日志级别、日志分类、日志内容。</p>
<pre><code class="javascript">// started.js
var log4js = require(&#39;log4js&#39;);
var logger = log4js.getLogger();
logger.debug(&#39;hello world&#39;);

// 输出：
// [2017-02-28 21:28:22.853] [DEBUG] [default] - hello world
</code></pre>
<h2 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h2><p><code>logger.setLevel(&#39;INFO&#39;);</code> 表示想要打印的最低级别的日志是<code>INFO</code>，也就是说，调用类似<code>logger.debug()</code>等级别低于<code>INFO</code>的接口，日志是不会打印出来的。</p>
<pre><code class="javascript">var log4js = require(&#39;log4js&#39;);
var logger = log4js.getLogger();
logger.setLevel(&#39;INFO&#39;);

logger.debug(&#39;level: debug&#39;);
logger.info(&#39;level: info&#39;);
logger.error(&#39;level: error&#39;);

// 输出如下：
// [2017-02-28 21:50:45.372] [INFO] [default] - level: info
// [2017-02-28 21:50:45.376] [ERROR] [default] - level: error
</code></pre>
<h2 id="日志类别"><a href="#日志类别" class="headerlink" title="日志类别"></a>日志类别</h2><p>除级别外，还可以对日志进行分类，<code>log4js.getLogger(category)</code>，如下所示</p>
<pre><code class="javascript">var log4js = require(&#39;log4js&#39;);
var alogger = log4js.getLogger(&#39;category-a&#39;);
var blogger = log4js.getLogger(&#39;category-b&#39;);

alogger.info(&#39;hello&#39;);
blogger.info(&#39;hello&#39;);

// 输出如下：
// [2017-02-28 22:36:57.570] [INFO] category-a - hello
// [2017-02-28 22:36:57.574] [INFO] category-b - hello
</code></pre>
<h2 id="appenders"><a href="#appenders" class="headerlink" title="appenders"></a>appenders</h2><p>appenders指定日志输出的位置，可以同时配置多个，用category进行区分。比如 <code>log4js.getLogger(&#39;info&#39;)</code> 应用的就是 <code>type</code> 为 <code>dateFile</code> 的配置。</p>
<p>可以注意到，<code>type</code> 为 <code>console</code> 的配置没有声明 <code>category</code> ，因此，所有的日志都会打印到控制台。</p>
<pre><code class="javascript">var log4js = require(&#39;log4js&#39;);

log4js.configure(&#123;
    appenders: [
        &#123; type: &#39;console&#39;&#125;,
        &#123; type: &#39;dateFile&#39;, filename: &#39;./logs/info.log&#39;, category: &#39;info&#39; &#125;
    ]
&#125;);

var logger = log4js.getLogger(&#39;info&#39;);
logger.setLevel(&#39;INFO&#39;);

logger.trace(&#39;trace&#39;);
logger.debug(&#39;debug&#39;);
logger.info(&#39;info&#39;);

// 输出如下：
// [2017-02-28 22:51:30.723] [INFO] info - info
</code></pre>
<h2 id="express应用"><a href="#express应用" class="headerlink" title="express应用"></a>express应用</h2><p>一个比较简单的例子如下，日志全部打印到控制台。</p>
<pre><code class="javascript">var express = require(&#39;express&#39;);
var log4js = require(&#39;log4js&#39;);
var app = express();

log4js.configure(&#123;
    appenders: [
        &#123; type: &#39;console&#39;, category: &#39;app&#39; &#125;
    ]
&#125;);

var logger = log4js.getLogger(&#39;app&#39;);

logger.setLevel(&#39;INFO&#39;);  // 级别 &gt; INFO 的日志才会被打印

app.use( log4js.connectLogger(logger) );

app.use(function(req, res, next)&#123;
    res.send(&#39;ok&#39;);
&#125;);

app.listen(3000);
</code></pre>
<p>访问 <a target="_blank" rel="noopener" href="http://127.0.0.1:3000/">http://127.0.0.1:3000</a> ，打印日志如下</p>
<pre><code class="bash">[2017-03-01 00:28:29.301] [INFO] app - ::ffff:127.0.0.1 - - &quot;GET / HTTP/1.1&quot; 304 - &quot;&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36&quot;
</code></pre>
<p><code>log4js.connectLogger(logger)</code> 时，可以声明日志的级别。</p>
<pre><code class="javascript">// 级别 &gt; INFO 的日志才会被打印
logger.setLevel(&#39;INFO&#39;);

// 日志的级别是 WARN
app.use( log4js.connectLogger(logger, &#123;level: &#39;WARN&#39;&#125;) );
</code></pre>
<p>注意，如果声明的日志级别低于<code>logger.setLevel(level)</code>限定的级别，那么日志不会被打印，如下例子。</p>
<pre><code class="javascript">logger.setLevel(&#39;INFO&#39;);

app.use( log4js.connectLogger(logger, &#123;level: &#39;DEBUG&#39;&#125;) );
</code></pre>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p>官网：<a target="_blank" rel="noopener" href="https://github.com/nomiddlename/log4js-node">https://github.com/nomiddlename/log4js-node</a></p>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2020-04-02T05:50:58.000Z" itemprop="datePublished">2020-04-02</time>
</div>
    
        <div class="article-category">
        <a class="article-category-link" href="/categories/Node-js/">Node.js</a>
        </div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-2020-05-node8-napi"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/article/2020/04/Node-js/2020-05-node8-napi.html">Node.js-buffer</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="N-API简介"><a href="#N-API简介" class="headerlink" title="N-API简介"></a>N-API简介</h2><p>Node.js 8.0 在2017年6月份发布，升级的特性中，包含了N-API。编写过或者使用过 node扩展的同学，不少都遇到过升级node版本，node扩展编译失败的情况。因为node扩展严重依赖于V8暴露的API，而node不同版本依赖的V8版本可能不同，一旦升级node版本，原先运行正常的node扩展就编译失败了。</p>
<p>这种情况对node生态圈无疑是不利的，N-API的引入正是试图改善这种情况的一种尝试。它跟底层JS引擎无关，只要N-API暴露的API足够稳定，那么node扩展的编写者就不用过分担忧node的升级问题。</p>
<h2 id="如何使用N-API"><a href="#如何使用N-API" class="headerlink" title="如何使用N-API"></a>如何使用N-API</h2><p>先强调一点，N-API并不是对原有node扩展实现方式的替代，它只是提供了一系列底层无关的API，来帮助开发者编写跨版本的node扩展。至于如何编写、编译、使用扩展，跟原来的差不多。</p>
<p>本文会从一个超级简单的例子，简单介绍N-API的使用，包括环境准备、编写扩展、编译、运行几个步骤。</p>
<blockquote>
<p>备注：当前N-API还处于试验阶段，官方文档提供的例子都是有问题的，如用于生产环境需格外谨慎。</p>
</blockquote>
<h2 id="1、环境准备"><a href="#1、环境准备" class="headerlink" title="1、环境准备"></a>1、环境准备</h2><p>首先，N-API是8.0版本引入的，首先确保本地安装了8.0版本。笔者用的是<code>nvm</code>，读者可自行选择安装方式。</p>
<pre><code class="bash">nvm i 8.0
nvm use 8.0
</code></pre>
<p>然后，安装<code>node-gyp</code>，编译扩展会用到。</p>
<pre><code class="bash">npm install -g node-gyp
</code></pre>
<p>创建项目目录，并初始化<code>package.json</code>。</p>
<pre><code class="bash">mkdir hello &amp; cd hello # 目录名随便起
npm init -f
</code></pre>
<h2 id="2、编写扩展"><a href="#2、编写扩展" class="headerlink" title="2、编写扩展"></a>2、编写扩展</h2><p>创建<code>hello.cc</code>作为扩展的源文件。</p>
<pre><code class="bash">mkdir src
touch src/hello.cc
</code></pre>
<p>编辑<code>hello.cc</code>，输入如下内容。</p>
<pre><code class="c">#include &lt;node_api.h&gt;

// 实际暴露的方法，这里只是简单返回一个字符串
napi_value HelloMethod (napi_env env, napi_callback_info info) &#123;
    napi_value world;
    napi_create_string_utf8(env, &quot;world&quot;, 5, &amp;world);
    return world;
&#125;

// 扩展的初始化方法，其中
// env：环境变量
// exports、module：node模块中对外暴露的对象
void Init (napi_env env, napi_value exports, napi_value module, void* priv) &#123;
    // napi_property_descriptor 为结构体，作用是描述扩展暴露的 属性/方法 的描述
    napi_property_descriptor desc = &#123; &quot;hello&quot;, 0, HelloMethod, 0, 0, 0, napi_default, 0 &#125;;
    napi_define_properties(env, exports, 1, &amp;desc);  // 定义暴露的方法
&#125;

NAPI_MODULE(hello, Init);  // 注册扩展，扩展名叫做hello，Init为扩展的初始化方法
</code></pre>
<h2 id="3、编译扩展"><a href="#3、编译扩展" class="headerlink" title="3、编译扩展"></a>3、编译扩展</h2><p>首先，创建编译描述文件<code>binding.gyp</code>。</p>
<pre><code class="json">&#123;
  &quot;targets&quot;: [
    &#123;
      &quot;target_name&quot;: &quot;hello&quot;,
      &quot;sources&quot;: [ &quot;./src/hello.cc&quot; ]
    &#125;
  ]
&#125;
</code></pre>
<p>然后，运行如下命令进行编译。</p>
<pre><code class="bash">node-gyp rebuild
</code></pre>
<h2 id="4、调用扩展"><a href="#4、调用扩展" class="headerlink" title="4、调用扩展"></a>4、调用扩展</h2><p>未方便调用扩展，先安装<code>bindings</code>。</p>
<pre><code class="bash">npm install --save bindings
</code></pre>
<p>然后，创建<code>app.js</code>，调用刚编译的扩展。</p>
<pre><code class="javascript">var addon = require(&#39;bindings&#39;)(&#39;hello&#39;);

console.log( addon.hello() );  // world
</code></pre>
<p>运行代码，由于N-API当前尚处于Experimental阶段，记得加上<code>--napi-modules</code>标记。</p>
<pre><code class="bash">node --napi-modules app.js
</code></pre>
<p>输出如下</p>
<pre><code class="bash">&#123;&quot;path&quot;:&quot;/data/github/abi-stable-node-addon-examples/1_hello_world/napi/build/Release/hello.node&quot;&#125;
world
(node:6500) Warning: N-API is an experimental feature and could change at any time.
</code></pre>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p>N-API：<a target="_blank" rel="noopener" href="https://nodejs.org/api/n-api.html">https://nodejs.org/api/n-api.html</a></p>
<p>C++ Addons：<a target="_blank" rel="noopener" href="https://nodejs.org/api/addons.html">https://nodejs.org/api/addons.html</a></p>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2020-04-02T05:50:58.000Z" itemprop="datePublished">2020-04-02</time>
</div>
    
        <div class="article-category">
        <a class="article-category-link" href="/categories/Node-js/">Node.js</a>
        </div>
    
    
    </div>
</footer>

</article>

    
  

  
    <nav class="pagination">
        <a class="extend prev" rel="prev" href="/page/5/">Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/7/">Next</a>
    </nav>
  
</div>

                </section>
            </section>

            
            <aside class="sidebar sidebar-search-fix">
                

    <div class="search">
    <div class="has-icon-right">
        <input type="text" class="form-input" id="search" placeholder="SEARCH" autocomplete="off">
        <div class="form-icon">
            <box-icon name='search' color="#3c4859"></box-icon>
        </div>
    </div>
    <div class="search-result" id="search-ps"></div>
</div>


<div class="widget" id="widget">
    
      
    
      
  <div class="widget-wrap widget-cate">
    <div class="widget-title"><span>Categories</span></div>
    <div class="widget-inner">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Node-js/">Node.js</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Windows/">Windows</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/web%E5%89%8D%E7%AB%AF/">web前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%85%B6%E5%AE%83/">其它</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/">工具使用</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/">微信小程序</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%98%E8%85%BE%E6%89%8B%E6%9C%BA/">折腾手机</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%8E%A9%E8%BD%AC%E6%9C%8D%E5%8A%A1%E5%99%A8/">玩转服务器</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/">自动化测试</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap widget-tags">
    <div class="widget-title"><span>Tags</span></div>
    <div class="widget-inner">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AWSC/" rel="tag">AWSC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ajax/" rel="tag">Ajax</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-Stuido/" rel="tag">Android Stuido</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Apache/" rel="tag">Apache</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Django/" rel="tag">Django</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Esc/" rel="tag">Esc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/G-140W-CS/" rel="tag">G-140W-CS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML5/" rel="tag">HTML5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/" rel="tag">HTTP状态码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HUAWEI/" rel="tag">HUAWEI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Html/" rel="tag">Html</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ICP/" rel="tag">ICP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JSON/" rel="tag">JSON</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jquery/" rel="tag">Jquery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LAMP/" rel="tag">LAMP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lodash/" rel="tag">Lodash</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MD5/" rel="tag">MD5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MUI/" rel="tag">MUI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Manjaro/" rel="tag">Manjaro</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown/" rel="tag">Markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Matplotlib/" rel="tag">Matplotlib</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mysql/" rel="tag">Mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/" rel="tag">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PyInstaller/" rel="tag">PyInstaller</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Reg/" rel="tag">Reg</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SEM/" rel="tag">SEM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SEO/" rel="tag">SEO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SSL%E8%AF%81%E4%B9%A6/" rel="tag">SSL证书</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Selenium/" rel="tag">Selenium</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ubuntu/" rel="tag">Ubuntu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/" rel="tag">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue3/" rel="tag">Vue3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Webpack/" rel="tag">Webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows10/" rel="tag">Windows10</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/XHTML/" rel="tag">XHTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/YOLO/" rel="tag">YOLO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/apache/" rel="tag">apache</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/app%E4%B8%8A%E6%9E%B6/" rel="tag">app上架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bug/" rel="tag">bug</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cmd/" rel="tag">cmd</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/" rel="tag">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/darkflow/" rel="tag">darkflow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/express/" rel="tag">express</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/" rel="tag">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pacman/" rel="tag">pacman</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php/" rel="tag">php</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pip/" rel="tag">pip</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pm2/" rel="tag">pm2</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/socket-io/" rel="tag">socket.io</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/turtle/" rel="tag">turtle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/wechat/" rel="tag">wechat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/windows11/" rel="tag">windows11</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/wordcloud/" rel="tag">wordcloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B4%E6%9C%AB%E6%80%BB%E7%BB%93/" rel="tag">年末总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8A%93%E5%8C%85/" rel="tag">抓包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA/" rel="tag">虚拟主机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E8%91%97/" rel="tag">软著</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap widget-recent-posts">
    <div class="widget-title"><span>Recent Posts</span></div>
    <div class="widget-inner">
      <ul>
        
          <li>
            <a href="/article/2021/07/web%E5%89%8D%E7%AB%AF/2021-07-%E6%89%8B%E5%86%99mini-vue3%E7%B3%BB%E7%BB%9F.html">手写mini-Vue3系统,探究原理</a>
          </li>
        
          <li>
            <a href="/article/2021/07/Windows/2021-07-Window10%E5%A6%82%E4%BD%95%E5%8D%87%E7%BA%A7Window11%EF%BC%88%E4%BD%93%E9%AA%8C%E7%89%88%EF%BC%89%E8%AF%A6%E7%BB%86%E6%B5%81%E7%A8%8B.html">Window10升级Window11（体验版dev）详细流程</a>
          </li>
        
          <li>
            <a href="/article/2021/07/Windows/2021-07-%E5%AF%86%E9%92%A5%E5%8D%87%E7%BA%A7windows%E4%B8%93%E4%B8%9A%E7%89%88%E5%8D%87%E7%BA%A7%E5%AF%86%E9%92%A5%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98.html">密钥升级windows专业版，升级失败，之前密钥丢失问题</a>
          </li>
        
          <li>
            <a href="/article/2021/06/%E5%85%B6%E5%AE%83/2021-06-%E5%BA%94%E7%94%A8%E5%AE%9D%E4%B8%8A%E6%9E%B6%E6%8C%87%E5%8D%97.html">应用宝上架指南【详细教程】</a>
          </li>
        
          <li>
            <a href="/article/2021/03/%E5%85%B6%E5%AE%83/2021-03-%E9%98%BF%E9%87%8C%E4%BA%91%E7%94%B3%E8%AF%B7%E8%BD%AF%E4%BB%B6%E8%91%97%E4%BD%9C%E6%9D%83%E6%B5%81%E7%A8%8B.html">阿里云申请软件著作权流程</a>
          </li>
        
      </ul>
    </div>
  </div>

    
      
  <div class="widget-wrap widget-archive">
    <div class="widget-title"><span>Archive</span></div>
    <div class="widget-inner">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/">2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/">2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/">2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/">2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/">2015</a></li></ul>
    </div>
  </div>


    
</div>

<div id="backtop"><i class="icon icon-arrow-up"></i></div>
            </aside>
            
        </div>
    </div>

    <footer class="footer">
  <div class="footer-wave">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1440 320"><path fill="#3c4859" fill-opacity="1" d="M0,160L60,181.3C120,203,240,245,360,240C480,235,600,181,720,186.7C840,192,960,256,1080,261.3C1200,267,1320,213,1380,186.7L1440,160L1440,320L1380,320C1320,320,1200,320,1080,320C960,320,840,320,720,320C600,320,480,320,360,320C240,320,120,320,60,320L0,320Z"></path></svg>
  </div>

  <div class="footer-wrap">
    <div class="footer-inner">
      Oct1a &copy;
        2021<br> Powered By Hexo · Theme By <a href="https://github.com/lh1me/hexo-theme-aomori" target="_blank">Aomori</a>
          <br>
          <a target="_blank" rel="noopener" href="https://beian.miit.gov.cn" style="text-decoration:none"><img width="15" src="//img.alicdn.com/tfs/TB1..50QpXXXXX7XpXXXXXXXXXX-40-40.png"><span style="margin-left:8px">闽ICP备14018417号</span></a>
    </div>

  </div>

</footer>



    

        
<script src="/dist/build.js?1619416789282.js"></script>

          
<script src="/dist/custom.js?1619416789282.js"></script>


            

                

                    

</body>

</html>